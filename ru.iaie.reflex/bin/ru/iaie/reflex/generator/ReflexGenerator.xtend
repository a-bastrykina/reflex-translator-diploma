/*
 * generated by Xtext 2.20.0
 */
package ru.iaie.reflex.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import ru.iaie.reflex.reflex.Program
import ru.iaie.reflex.reflex.Process
import java.util.HashMap
import java.util.Map
import ru.iaie.reflex.reflex.State
import org.eclipse.emf.ecore.EObject
import ru.iaie.reflex.reflex.StopProcStat
import ru.iaie.reflex.reflex.Body

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class ReflexGenerator extends AbstractGenerator {

	private Map<String, String> procIdentifiers = new HashMap
	private Map<String, String> stateIdentifiers = new HashMap

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val program = resource.allContents.toIterable.filter(Program).get(0)
		val fileContent = translateProgram(program)
		fsa.generateFile('''«program.name.toLowerCase».c''', fileContent)
	}

	def getProcessId(Process proc) {
		if (!procIdentifiers.containsKey(proc.name)) {
			val id = proc.name.toUpperCase
			procIdentifiers.put(proc.name, id)
		}
		return procIdentifiers.get(proc.name)
	}

	def generateProcessesEnum(Program prog) {
		return '''
			enum «ReflexIdentifiers.PROC_ENUM_ID» {
				«FOR proc : prog.processes»
					«getProcessId(proc)»,
				«ENDFOR»
			}
		'''
	}

	def getStateId(Process proc, State state) {
		val key = '''«proc.name».«state.name»'''
		if (!stateIdentifiers.containsKey(key)) {
			val id = '''«proc.name.toUpperCase»_«state.name.toUpperCase»'''
			stateIdentifiers.put(key, id)
		}
		return stateIdentifiers.get(key)
	}

	def generateStateEnum(Process proc) {
		return '''
			enum «proc.name»_STATES {
				«FOR state : proc.states»
					«getStateId(proc, state)»,
				«ENDFOR»
				«proc.name»«ReflexIdentifiers.STOP_STATE_ID_SUFFIX»,
				«proc.name»«ReflexIdentifiers.ERR_STATE_ID_SUFFIX»	
			}
		'''
	}

	def generateTimers(Program prog) {
		return '''
			int «ReflexIdentifiers.TIMER_ARRAY_NAME»[«ReflexIdentifiers.PROC_COUNT_VAR»];
		'''
	}

	def generateStatesArray(Program prog) {
		return '''
			int «ReflexIdentifiers.PROC_STATES_ARRAY_NAME»[«ReflexIdentifiers.PROC_COUNT_VAR»];
		'''
	}

	def translateProgram(Program prog) {
		return '''
			#include <stdio.h>
			#include <stdlib.h>
			«generateProgramInfo(prog)»
			int main() {
				while (1) {
					int i = 0;
					for (; i < «ReflexIdentifiers.PROC_COUNT_VAR»; i++) {
					«FOR proc : prog.processes»
						«translateProcess(proc)»
					«ENDFOR»
					}
				}
			}
		'''
	}

	def generateProgramInfo(Program prog) {
		return '''
			int «ReflexIdentifiers.PROC_COUNT_VAR» = «prog.processes.length»;
			«generateTimers(prog)»
			«generateStatesArray(prog)»
			«generateProcessesEnum(prog)»
			«FOR proc : prog.processes»
				«generateStateEnum(proc)»
			«ENDFOR»
		'''
	}

	def translateProcess(Process proc) {
		return '''
			switch («ReflexIdentifiers.PROC_STATES_ARRAY_NAME»[«getProcessId(proc)»]) {
				«FOR state : proc.states»
					«translateState(proc, state)»
				«ENDFOR»
			}
		'''
	}

	def translateState(Process proc, State state) {
		return '''
			case «getStateId(proc, state)»: {
			«FOR stat : state.stateFunction.statements»
				«translateStatement(proc, state, stat)»
			«ENDFOR»
			}
		'''
	}

	def translateStatement(Process proc, State state, EObject statement) {
		if (statement instanceof StopProcStat) {
			return translateStopProcStat(proc, state, statement);
		} else if (statement instanceof Body) {
			return '''
				«FOR stat : statement.statements»
				«translateStatement(proc, state, stat)»
				«ENDFOR»
			'''
		}
	}

	def translateStopProcStat(Process proc, State state, StopProcStat sps) {
		return '''
			«ReflexIdentifiers.PROC_STATES_ARRAY_NAME»[«getProcessId(proc)»] =  «proc.name»«ReflexIdentifiers.STOP_STATE_ID_SUFFIX»;
		'''
	}
}
