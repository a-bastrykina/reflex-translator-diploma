/*
 * generated by Xtext 2.20.0
 */
package ru.iaie.reflex.validation

import org.eclipse.xtext.validation.Check
import ru.iaie.reflex.reflex.ReflexPackage
import ru.iaie.reflex.reflex.SetStateStat
import ru.iaie.reflex.reflex.Process

import static extension ru.iaie.reflex.utils.ReflexModelUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*
import ru.iaie.reflex.reflex.ErrorStat
import ru.iaie.reflex.reflex.StopProcStat
import ru.iaie.reflex.reflex.StartProcStat

/** 
 * This class contains custom validation rules. 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ReflexValidator extends AbstractReflexValidator {

	@Check def void checkForNextState(SetStateStat setStateStat) {
		if (setStateStat.isNext()) {
			val state = setStateStat.getContainerOfType(ru.iaie.reflex.reflex.State)
			val process = setStateStat.getContainerOfType(Process)
			val callingStateIndex = process.states.indexOf(state)
			if (callingStateIndex + 1 >= process.states.length) {
				error("Invalid state transition: no next state in the process",
					ReflexPackage.eINSTANCE.setStateStat_Next)
			}
		}
	}

	@Check def void checkStateTransitions(ru.iaie.reflex.reflex.State state) {
		if (state.isLooped) return;
		val stateTransitions = state.eAllContents.filter(SetStateStat)
		if (stateTransitions.isEmpty) {
			val selfStopTransitions = state.eAllContents.filter(StopProcStat).filter[selfStop]
			if (selfStopTransitions.isEmpty) {
				val selfErrorTransitions = state.eAllContents.filter(ErrorStat).filter[selfError]
				if (selfErrorTransitions.isEmpty) {
					error('''Potential cycle in state «state.name»: no state transitions declared''',
						ReflexPackage.eINSTANCE.state_Name)
				}
			}
		}
	}

	@Check def void checkStartStatement(StartProcStat startStat) {
		val selfProcess = startStat.getContainerOfType(Process)
		val procName = startStat.process.name;
		if (selfProcess.name.equals(procName)) {
			warning('''Use 'restart' statement for restarting current process''',
				ReflexPackage.eINSTANCE.startProcStat_Process)
		}
	}
	
	@Check def void checkStopStatement(StopProcStat stopStat) {
		val selfProcess = stopStat.getContainerOfType(Process)
		val procName = stopStat.process.name;
		if (selfProcess.name.equals(procName)) {
			warning('''Use 'stop' without argument to stop current process''',
				ReflexPackage.eINSTANCE.stopProcStat_Process)
		}
	}
	
	@Check def void checkErrorStatement(ErrorStat errorStat) {
		val selfProcess = errorStat.getContainerOfType(Process)
		val procName = errorStat.process.name;
		if (selfProcess.name.equals(procName)) {
			warning('''Use 'error' without argument to set current process state to error''',
				ReflexPackage.eINSTANCE.errorStat_Process)
		}
	}

	// TODO: error when assigned to const or enum

}
