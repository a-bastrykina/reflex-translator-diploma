/**
 * generated by Xtext 2.20.0
 */
package ru.iaie.reflex.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.common.collect.Iterators;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import ru.iaie.reflex.reflex.AssignmentExpression;
import ru.iaie.reflex.reflex.Const;
import ru.iaie.reflex.reflex.DeclaredVariable;
import ru.iaie.reflex.reflex.EnumMember;
import ru.iaie.reflex.reflex.ErrorStat;
import ru.iaie.reflex.reflex.GlobalVariable;
import ru.iaie.reflex.reflex.IdReference;
import ru.iaie.reflex.reflex.PhysicalVariable;
import ru.iaie.reflex.reflex.Program;
import ru.iaie.reflex.reflex.ProgramVariable;
import ru.iaie.reflex.reflex.ReflexPackage;
import ru.iaie.reflex.reflex.Register;
import ru.iaie.reflex.reflex.RegisterType;
import ru.iaie.reflex.reflex.SetStateStat;
import ru.iaie.reflex.reflex.StartProcStat;
import ru.iaie.reflex.reflex.StopProcStat;
import ru.iaie.reflex.reflex.TimeoutFunction;
import ru.iaie.reflex.utils.ExpressionUtil;
import ru.iaie.reflex.utils.ReflexModelUtil;
import ru.iaie.reflex.validation.AbstractReflexValidator;

/**
 * This class contains custom validation rules.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class ReflexValidator extends AbstractReflexValidator {
  private static ReflexPackage ePackage = ReflexPackage.eINSTANCE;
  
  @Check
  public void checkForNextState(final SetStateStat setStateStat) {
    boolean _isNext = setStateStat.isNext();
    if (_isNext) {
      final ru.iaie.reflex.reflex.State state = EcoreUtil2.<ru.iaie.reflex.reflex.State>getContainerOfType(setStateStat, ru.iaie.reflex.reflex.State.class);
      final ru.iaie.reflex.reflex.Process process = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(setStateStat, ru.iaie.reflex.reflex.Process.class);
      final int callingStateIndex = process.getStates().indexOf(state);
      int _length = ((Object[])Conversions.unwrapArray(process.getStates(), Object.class)).length;
      boolean _greaterEqualsThan = ((callingStateIndex + 1) >= _length);
      if (_greaterEqualsThan) {
        this.error("Invalid state transition: no next state in the process", ReflexValidator.ePackage.getSetStateStat_Next());
      }
    }
  }
  
  @Check
  public void checkStateTransitions(final ru.iaie.reflex.reflex.State state) {
    boolean _isLooped = state.isLooped();
    if (_isLooped) {
      return;
    }
    final Iterator<SetStateStat> stateTransitions = Iterators.<SetStateStat>filter(state.eAllContents(), SetStateStat.class);
    boolean _isEmpty = IteratorExtensions.isEmpty(stateTransitions);
    if (_isEmpty) {
      final Function1<StopProcStat, Boolean> _function = (StopProcStat it) -> {
        return Boolean.valueOf(ReflexModelUtil.selfStop(it));
      };
      final Iterator<StopProcStat> selfStopTransitions = IteratorExtensions.<StopProcStat>filter(Iterators.<StopProcStat>filter(state.eAllContents(), StopProcStat.class), _function);
      boolean _isEmpty_1 = IteratorExtensions.isEmpty(selfStopTransitions);
      if (_isEmpty_1) {
        final Function1<ErrorStat, Boolean> _function_1 = (ErrorStat it) -> {
          return Boolean.valueOf(ReflexModelUtil.selfError(it));
        };
        final Iterator<ErrorStat> selfErrorTransitions = IteratorExtensions.<ErrorStat>filter(Iterators.<ErrorStat>filter(state.eAllContents(), ErrorStat.class), _function_1);
        boolean _isEmpty_2 = IteratorExtensions.isEmpty(selfErrorTransitions);
        if (_isEmpty_2) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("Potential cycle in state ");
          String _name = state.getName();
          _builder.append(_name);
          _builder.append(": no state transitions declared");
          this.error(_builder.toString(), 
            ReflexValidator.ePackage.getState_Name());
        }
      }
    }
  }
  
  @Check
  public void checkStartStatement(final StartProcStat startStat) {
    final ru.iaie.reflex.reflex.Process selfProcess = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(startStat, ru.iaie.reflex.reflex.Process.class);
    final String procName = startStat.getProcess().getName();
    boolean _equals = selfProcess.getName().equals(procName);
    if (_equals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Use \'restart\' statement for restarting current process");
      this.warning(_builder.toString(), ReflexValidator.ePackage.getStartProcStat_Process());
    }
  }
  
  @Check
  public void checkStopStatement(final StopProcStat stopStat) {
    final ru.iaie.reflex.reflex.Process selfProcess = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(stopStat, ru.iaie.reflex.reflex.Process.class);
    final String procName = stopStat.getProcess().getName();
    boolean _equals = selfProcess.getName().equals(procName);
    if (_equals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Use \'stop\' without argument to stop current process");
      this.warning(_builder.toString(), ReflexValidator.ePackage.getStopProcStat_Process());
    }
  }
  
  @Check
  public void checkErrorStatement(final ErrorStat errorStat) {
    final ru.iaie.reflex.reflex.Process selfProcess = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(errorStat, ru.iaie.reflex.reflex.Process.class);
    final String procName = errorStat.getProcess().getName();
    boolean _equals = selfProcess.getName().equals(procName);
    if (_equals) {
      this.warning("Use \'error\' without argument to set current process state to error", ReflexValidator.ePackage.getErrorStat_Process());
    }
  }
  
  @Check
  public void checkAssignVariable(final AssignmentExpression expr) {
    boolean _hasAssignment = ExpressionUtil.hasAssignment(expr);
    if (_hasAssignment) {
      final IdReference assignVar = expr.getAssignVar();
      if ((assignVar instanceof PhysicalVariable)) {
        RegisterType _mappedPortType = ReflexModelUtil.getMappedPortType(((PhysicalVariable)assignVar));
        boolean _equals = Objects.equal(_mappedPortType, RegisterType.INPUT);
        if (_equals) {
          this.warning("An attempt to assign value into variable mapped on input port", 
            ReflexValidator.ePackage.getAssignmentExpression_AssignVar());
        }
      }
      if (((assignVar instanceof Const) || (assignVar instanceof EnumMember))) {
        this.error("Can\'t assign values to constants or enum members", ReflexValidator.ePackage.getAssignmentExpression_AssignVar());
      }
    }
  }
  
  @Check
  public void checkOutputVarUsagesInAssignment(final PhysicalVariable physVar) {
    RegisterType _mappedPortType = ReflexModelUtil.getMappedPortType(physVar);
    boolean _equals = Objects.equal(_mappedPortType, RegisterType.OUTPUT);
    if (_equals) {
      final Program program = EcoreUtil2.<Program>getContainerOfType(physVar, Program.class);
      boolean usedInAssignment = ReflexModelUtil.containsReferencesOfType(program, physVar, ReflexValidator.ePackage.getAssignmentExpression_AssignVar());
      if ((!usedInAssignment)) {
        this.warning("Variable mapped on output port is not used in assignment", ReflexValidator.ePackage.getPhysicalVariable_Name());
      }
    }
  }
  
  @Check
  public void checkStateReachability(final ru.iaie.reflex.reflex.State state) {
    final ru.iaie.reflex.reflex.Process process = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(state, ru.iaie.reflex.reflex.Process.class);
    int curStateIndex = process.getStates().indexOf(state);
    if ((curStateIndex == 0)) {
      return;
    }
    boolean transitionExists = ReflexModelUtil.containsReferencesOfType(process, state, ReflexValidator.ePackage.getSetStateStat_State());
    if ((!transitionExists)) {
      final ru.iaie.reflex.reflex.State prevState = process.getStates().get((curStateIndex - 1));
      final Function1<SetStateStat, Boolean> _function = (SetStateStat it) -> {
        return Boolean.valueOf(it.isNext());
      };
      final Iterable<SetStateStat> nextStateTransitions = IterableExtensions.<SetStateStat>filter(EcoreUtil2.<SetStateStat>eAllOfType(prevState, SetStateStat.class), _function);
      transitionExists = (transitionExists || (!IterableExtensions.isEmpty(nextStateTransitions)));
    }
    if ((!transitionExists)) {
      this.warning("State is unreachable", ReflexValidator.ePackage.getState_Name());
    }
  }
  
  @Check
  public void checkTimeoutVariable(final TimeoutFunction func) {
    boolean _isReferencedTimeout = ReflexModelUtil.isReferencedTimeout(func);
    if (_isReferencedTimeout) {
      final Program program = EcoreUtil2.<Program>getContainerOfType(func, Program.class);
      final IdReference timeContainer = func.getRef();
      if ((timeContainer instanceof ProgramVariable)) {
        boolean _containsReferencesOfType = ReflexModelUtil.containsReferencesOfType(program, timeContainer, ReflexValidator.ePackage.getAssignmentExpression_AssignVar());
        boolean _not = (!_containsReferencesOfType);
        if (_not) {
          this.warning("Uninitialized variable is used in timeout", ReflexValidator.ePackage.getTimeAmountOrRef_Ref());
        }
      }
    }
  }
  
  @Check
  public void checkNameShadowing(final ru.iaie.reflex.reflex.Process process) {
    final Map<String, EObject> globalCtx = CollectionLiterals.<String, EObject>newHashMap();
    final Program program = EcoreUtil2.<Program>getContainerOfType(process, Program.class);
    final Function1<GlobalVariable, String> _function = (GlobalVariable it) -> {
      return ReflexModelUtil.getName(it);
    };
    final Function1<GlobalVariable, GlobalVariable> _function_1 = (GlobalVariable v) -> {
      return v;
    };
    globalCtx.putAll(IterableExtensions.<GlobalVariable, String, GlobalVariable>toMap(program.getGlobalVars(), _function, _function_1));
    final Function1<Register, String> _function_2 = (Register it) -> {
      return it.getName();
    };
    final Function1<Register, Register> _function_3 = (Register v) -> {
      return v;
    };
    globalCtx.putAll(IterableExtensions.<Register, String, Register>toMap(program.getRegisters(), _function_2, _function_3));
    final Function1<ru.iaie.reflex.reflex.Enum, EList<EnumMember>> _function_4 = (ru.iaie.reflex.reflex.Enum it) -> {
      return it.getEnumMembers();
    };
    final Function1<EnumMember, String> _function_5 = (EnumMember it) -> {
      return it.getName();
    };
    final Function1<EnumMember, EnumMember> _function_6 = (EnumMember v) -> {
      return v;
    };
    globalCtx.putAll(IterableExtensions.<EnumMember, String, EnumMember>toMap(Iterables.<EnumMember>concat(ListExtensions.<ru.iaie.reflex.reflex.Enum, EList<EnumMember>>map(program.getEnums(), _function_4)), _function_5, _function_6));
    final Function1<Const, String> _function_7 = (Const it) -> {
      return it.getName();
    };
    final Function1<Const, Const> _function_8 = (Const v) -> {
      return v;
    };
    globalCtx.putAll(IterableExtensions.<Const, String, Const>toMap(program.getConsts(), _function_7, _function_8));
    List<DeclaredVariable> _declaredVariables = ReflexModelUtil.getDeclaredVariables(process);
    for (final DeclaredVariable variable : _declaredVariables) {
      {
        EAttribute _xifexpression = null;
        boolean _isPhysical = ReflexModelUtil.isPhysical(variable);
        if (_isPhysical) {
          _xifexpression = ReflexValidator.ePackage.getPhysicalVariable_Name();
        } else {
          _xifexpression = ReflexValidator.ePackage.getProgramVariable_Name();
        }
        EAttribute ref = _xifexpression;
        boolean _containsKey = globalCtx.containsKey(ReflexModelUtil.getName(variable));
        if (_containsKey) {
          EObject shadowed = globalCtx.get(ReflexModelUtil.getName(variable));
          String errorMessage = null;
          boolean _matched = false;
          if (shadowed instanceof GlobalVariable) {
            _matched=true;
            StringConcatenation _builder = new StringConcatenation();
            _builder.append("Process variable shadows global variable \"");
            String _name = ReflexModelUtil.getName(((GlobalVariable)shadowed));
            _builder.append(_name);
            _builder.append("\"");
            errorMessage = _builder.toString();
          }
          if (!_matched) {
            if (shadowed instanceof Register) {
              _matched=true;
              StringConcatenation _builder = new StringConcatenation();
              _builder.append("Process variable shadows port name \"");
              String _name = ((Register)shadowed).getName();
              _builder.append(_name);
              _builder.append("\"");
              errorMessage = _builder.toString();
            }
          }
          if (!_matched) {
            if (shadowed instanceof EnumMember) {
              _matched=true;
              StringConcatenation _builder = new StringConcatenation();
              _builder.append("Process variable shadows enum member name \"");
              String _name = ((EnumMember)shadowed).getName();
              _builder.append(_name);
              _builder.append("\"");
              errorMessage = _builder.toString();
            }
          }
          if (!_matched) {
            if (shadowed instanceof Const) {
              _matched=true;
              StringConcatenation _builder = new StringConcatenation();
              _builder.append("Process variable shadows constant name \"");
              String _name = ((Const)shadowed).getName();
              _builder.append(_name);
              _builder.append("\"");
              errorMessage = _builder.toString();
            }
          }
          this.error(errorMessage, variable, ref);
        }
      }
    }
  }
}
