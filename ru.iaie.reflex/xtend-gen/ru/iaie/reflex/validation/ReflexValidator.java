/**
 * generated by Xtext 2.20.0
 */
package ru.iaie.reflex.validation;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import ru.iaie.reflex.reflex.AssignmentExpression;
import ru.iaie.reflex.reflex.ErrorStat;
import ru.iaie.reflex.reflex.IdReference;
import ru.iaie.reflex.reflex.PhysicalVariable;
import ru.iaie.reflex.reflex.Program;
import ru.iaie.reflex.reflex.ReflexPackage;
import ru.iaie.reflex.reflex.RegisterType;
import ru.iaie.reflex.reflex.SetStateStat;
import ru.iaie.reflex.reflex.StartProcStat;
import ru.iaie.reflex.reflex.StopProcStat;
import ru.iaie.reflex.utils.ExpressionUtil;
import ru.iaie.reflex.utils.ReflexModelUtil;
import ru.iaie.reflex.validation.AbstractReflexValidator;

/**
 * This class contains custom validation rules.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class ReflexValidator extends AbstractReflexValidator {
  @Check
  public void checkForNextState(final SetStateStat setStateStat) {
    boolean _isNext = setStateStat.isNext();
    if (_isNext) {
      final ru.iaie.reflex.reflex.State state = EcoreUtil2.<ru.iaie.reflex.reflex.State>getContainerOfType(setStateStat, ru.iaie.reflex.reflex.State.class);
      final ru.iaie.reflex.reflex.Process process = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(setStateStat, ru.iaie.reflex.reflex.Process.class);
      final int callingStateIndex = process.getStates().indexOf(state);
      int _length = ((Object[])Conversions.unwrapArray(process.getStates(), Object.class)).length;
      boolean _greaterEqualsThan = ((callingStateIndex + 1) >= _length);
      if (_greaterEqualsThan) {
        this.error("Invalid state transition: no next state in the process", 
          ReflexPackage.eINSTANCE.getSetStateStat_Next());
      }
    }
  }
  
  @Check
  public void checkStateTransitions(final ru.iaie.reflex.reflex.State state) {
    boolean _isLooped = state.isLooped();
    if (_isLooped) {
      return;
    }
    final Iterator<SetStateStat> stateTransitions = Iterators.<SetStateStat>filter(state.eAllContents(), SetStateStat.class);
    boolean _isEmpty = IteratorExtensions.isEmpty(stateTransitions);
    if (_isEmpty) {
      final Function1<StopProcStat, Boolean> _function = (StopProcStat it) -> {
        return Boolean.valueOf(ReflexModelUtil.selfStop(it));
      };
      final Iterator<StopProcStat> selfStopTransitions = IteratorExtensions.<StopProcStat>filter(Iterators.<StopProcStat>filter(state.eAllContents(), StopProcStat.class), _function);
      boolean _isEmpty_1 = IteratorExtensions.isEmpty(selfStopTransitions);
      if (_isEmpty_1) {
        final Function1<ErrorStat, Boolean> _function_1 = (ErrorStat it) -> {
          return Boolean.valueOf(ReflexModelUtil.selfError(it));
        };
        final Iterator<ErrorStat> selfErrorTransitions = IteratorExtensions.<ErrorStat>filter(Iterators.<ErrorStat>filter(state.eAllContents(), ErrorStat.class), _function_1);
        boolean _isEmpty_2 = IteratorExtensions.isEmpty(selfErrorTransitions);
        if (_isEmpty_2) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("Potential cycle in state ");
          String _name = state.getName();
          _builder.append(_name);
          _builder.append(": no state transitions declared");
          this.error(_builder.toString(), 
            ReflexPackage.eINSTANCE.getState_Name());
        }
      }
    }
  }
  
  @Check
  public void checkStartStatement(final StartProcStat startStat) {
    final ru.iaie.reflex.reflex.Process selfProcess = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(startStat, ru.iaie.reflex.reflex.Process.class);
    final String procName = startStat.getProcess().getName();
    boolean _equals = selfProcess.getName().equals(procName);
    if (_equals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Use \'restart\' statement for restarting current process");
      this.warning(_builder.toString(), 
        ReflexPackage.eINSTANCE.getStartProcStat_Process());
    }
  }
  
  @Check
  public void checkStopStatement(final StopProcStat stopStat) {
    final ru.iaie.reflex.reflex.Process selfProcess = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(stopStat, ru.iaie.reflex.reflex.Process.class);
    final String procName = stopStat.getProcess().getName();
    boolean _equals = selfProcess.getName().equals(procName);
    if (_equals) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("Use \'stop\' without argument to stop current process");
      this.warning(_builder.toString(), 
        ReflexPackage.eINSTANCE.getStopProcStat_Process());
    }
  }
  
  @Check
  public void checkErrorStatement(final ErrorStat errorStat) {
    final ru.iaie.reflex.reflex.Process selfProcess = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(errorStat, ru.iaie.reflex.reflex.Process.class);
    final String procName = errorStat.getProcess().getName();
    boolean _equals = selfProcess.getName().equals(procName);
    if (_equals) {
      this.warning("Use \'error\' without argument to set current process state to error", 
        ReflexPackage.eINSTANCE.getErrorStat_Process());
    }
  }
  
  @Check
  public void checkAssignVariable(final AssignmentExpression expr) {
    boolean _hasAssignment = ExpressionUtil.hasAssignment(expr);
    if (_hasAssignment) {
      final IdReference assignVar = expr.getAssignVar();
      if ((assignVar instanceof PhysicalVariable)) {
        RegisterType _mappedPortType = ReflexModelUtil.getMappedPortType(((PhysicalVariable)assignVar));
        boolean _equals = Objects.equal(_mappedPortType, RegisterType.INPUT);
        if (_equals) {
          this.warning("An attempt to assign value into variable mapped on input port", 
            ReflexPackage.eINSTANCE.getAssignmentExpression_AssignVar());
        }
      }
    }
  }
  
  @Check
  public void checkOutputVarUsagesInAssignment(final PhysicalVariable physVar) {
    RegisterType _mappedPortType = ReflexModelUtil.getMappedPortType(physVar);
    boolean _equals = Objects.equal(_mappedPortType, RegisterType.OUTPUT);
    if (_equals) {
      final Program container = EcoreUtil2.<Program>getContainerOfType(physVar, Program.class);
      HashSet<PhysicalVariable> target = CollectionLiterals.<PhysicalVariable>newHashSet(physVar);
      final ArrayList<EObject> refered = CollectionLiterals.<EObject>newArrayList();
      final EcoreUtil2.ElementReferenceAcceptor _function = (EObject referrer, EObject referenced, EReference reference, int index) -> {
        EReference _assignmentExpression_AssignVar = ReflexPackage.eINSTANCE.getAssignmentExpression_AssignVar();
        boolean _equals_1 = Objects.equal(reference, _assignmentExpression_AssignVar);
        if (_equals_1) {
          refered.add(referrer);
        }
      };
      final EcoreUtil2.ElementReferenceAcceptor acceptor = _function;
      EcoreUtil2.findCrossReferences(container, target, acceptor);
      boolean _isEmpty = refered.isEmpty();
      if (_isEmpty) {
        this.warning("Variable mapped on output port is not used in assignment", 
          ReflexPackage.eINSTANCE.getPhysicalVariable_Name());
      }
    }
  }
}
