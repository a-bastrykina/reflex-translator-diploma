/**
 * generated by Xtext 2.20.0
 */
package ru.iaie.reflex.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import ru.iaie.reflex.reflex.AssignmentExpression;
import ru.iaie.reflex.reflex.DeclaredVariable;
import ru.iaie.reflex.reflex.EnumMember;
import ru.iaie.reflex.reflex.ImportedVariable;
import ru.iaie.reflex.reflex.PrimaryExpression;
import ru.iaie.reflex.reflex.ProcessVariable;
import ru.iaie.reflex.reflex.Program;
import ru.iaie.reflex.reflex.ReflexPackage;
import ru.iaie.reflex.reflex.SetStateStat;
import ru.iaie.reflex.reflex.State;
import ru.iaie.reflex.scoping.AbstractReflexScopeProvider;
import ru.iaie.reflex.utils.ReflexModelUtil;

/**
 * This class contains custom scoping description.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class ReflexScopeProvider extends AbstractReflexScopeProvider {
  private final ReflexPackage ePackage = ReflexPackage.eINSTANCE;
  
  @Override
  public IScope getScope(final EObject ctx, final EReference ref) {
    if (((ctx instanceof SetStateStat) && Objects.equal(ref, this.ePackage.getSetStateStat_State()))) {
      final EList<State> candidates = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(ctx, ru.iaie.reflex.reflex.Process.class).getStates();
      return Scopes.scopeFor(candidates);
    }
    if (((ctx instanceof ImportedVariable) && Objects.equal(ref, this.ePackage.getImportedVariable_Variables()))) {
      final Function1<ProcessVariable, Boolean> _function = (ProcessVariable it) -> {
        return Boolean.valueOf(ReflexModelUtil.isShared(it));
      };
      final Iterable<ProcessVariable> candidates_1 = IterableExtensions.<ProcessVariable>filter(((ImportedVariable) ctx).getProcess().getVariables(), _function);
      return Scopes.scopeFor(candidates_1);
    }
    if ((ctx instanceof PrimaryExpression)) {
      EReference _primaryExpression_Reference = this.ePackage.getPrimaryExpression_Reference();
      boolean _equals = Objects.equal(ref, _primaryExpression_Reference);
      if (_equals) {
        final Program prog = EcoreUtil2.<Program>getContainerOfType(ctx, Program.class);
        final ru.iaie.reflex.reflex.Process proc = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(ctx, ru.iaie.reflex.reflex.Process.class);
        final ArrayList<EObject> candidates_2 = new ArrayList<EObject>();
        final Function1<ru.iaie.reflex.reflex.Enum, EList<EnumMember>> _function_1 = (ru.iaie.reflex.reflex.Enum it) -> {
          return it.getEnumMembers();
        };
        Iterables.<EObject>addAll(candidates_2, Iterables.<EObject>concat(ListExtensions.<ru.iaie.reflex.reflex.Enum, EList<EnumMember>>map(prog.getEnums(), _function_1)));
        candidates_2.addAll(prog.getConsts());
        candidates_2.addAll(prog.getGlobalVars());
        if ((proc != null)) {
          final Function1<ProcessVariable, Boolean> _function_2 = (ProcessVariable it) -> {
            return Boolean.valueOf(ReflexModelUtil.isDeclared(it));
          };
          Iterables.<EObject>addAll(candidates_2, IterableExtensions.<ProcessVariable>filter(proc.getVariables(), _function_2));
          final Function1<ImportedVariable, EList<DeclaredVariable>> _function_3 = (ImportedVariable it) -> {
            return it.getVariables();
          };
          Iterables.<EObject>addAll(candidates_2, Iterables.<EObject>concat(IterableExtensions.<ImportedVariable, EList<DeclaredVariable>>map(Iterables.<ImportedVariable>filter(proc.getVariables(), ImportedVariable.class), _function_3)));
        }
        return Scopes.scopeFor(candidates_2);
      }
    }
    if ((ctx instanceof AssignmentExpression)) {
      EReference _assignmentExpression_AssignVar = this.ePackage.getAssignmentExpression_AssignVar();
      boolean _equals_1 = Objects.equal(ref, _assignmentExpression_AssignVar);
      if (_equals_1) {
        final Program prog_1 = EcoreUtil2.<Program>getContainerOfType(ctx, Program.class);
        final ru.iaie.reflex.reflex.Process proc_1 = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(ctx, ru.iaie.reflex.reflex.Process.class);
        final ArrayList<EObject> candidates_3 = new ArrayList<EObject>();
        candidates_3.addAll(prog_1.getGlobalVars());
        if ((proc_1 != null)) {
          final Function1<ProcessVariable, Boolean> _function_4 = (ProcessVariable it) -> {
            return Boolean.valueOf(ReflexModelUtil.isDeclared(it));
          };
          Iterables.<EObject>addAll(candidates_3, IterableExtensions.<ProcessVariable>filter(proc_1.getVariables(), _function_4));
          final Function1<ImportedVariable, EList<DeclaredVariable>> _function_5 = (ImportedVariable it) -> {
            return it.getVariables();
          };
          Iterables.<EObject>addAll(candidates_3, Iterables.<EObject>concat(IterableExtensions.<ImportedVariable, EList<DeclaredVariable>>map(Iterables.<ImportedVariable>filter(proc_1.getVariables(), ImportedVariable.class), _function_5)));
        }
        return Scopes.scopeFor(candidates_3);
      }
    }
    return super.getScope(ctx, ref);
  }
}
