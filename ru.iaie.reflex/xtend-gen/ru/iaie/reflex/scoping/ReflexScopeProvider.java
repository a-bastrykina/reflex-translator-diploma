/**
 * generated by Xtext 2.20.0
 */
package ru.iaie.reflex.scoping;

import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.ArrayList;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import ru.iaie.reflex.reflex.AssignmentExpression;
import ru.iaie.reflex.reflex.EnumMember;
import ru.iaie.reflex.reflex.ImportedVariableList;
import ru.iaie.reflex.reflex.PrimaryExpression;
import ru.iaie.reflex.reflex.ProcessVariable;
import ru.iaie.reflex.reflex.Program;
import ru.iaie.reflex.reflex.ReflexPackage;
import ru.iaie.reflex.reflex.SetStateStat;
import ru.iaie.reflex.reflex.State;
import ru.iaie.reflex.reflex.TimeAmountOrRef;
import ru.iaie.reflex.scoping.AbstractReflexScopeProvider;
import ru.iaie.reflex.utils.ReflexModelUtil;

/**
 * This class contains custom scoping description.
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class ReflexScopeProvider extends AbstractReflexScopeProvider {
  private final ReflexPackage ePackage = ReflexPackage.eINSTANCE;
  
  @Override
  public IScope getScope(final EObject ctx, final EReference ref) {
    if (((ctx instanceof SetStateStat) && Objects.equal(ref, this.ePackage.getSetStateStat_State()))) {
      final EList<State> candidates = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(ctx, ru.iaie.reflex.reflex.Process.class).getStates();
      return Scopes.scopeFor(candidates);
    }
    if (((ctx instanceof ImportedVariableList) && Objects.equal(ref, this.ePackage.getImportedVariableList_Variables()))) {
      final Function1<ProcessVariable, Boolean> _function = (ProcessVariable it) -> {
        return Boolean.valueOf(ReflexModelUtil.isShared(it));
      };
      final Iterable<ProcessVariable> candidates_1 = IterableExtensions.<ProcessVariable>filter(((ImportedVariableList) ctx).getProcess().getVariables(), _function);
      return Scopes.scopeFor(candidates_1);
    }
    if (((((ctx instanceof PrimaryExpression) && Objects.equal(ref, this.ePackage.getPrimaryExpression_Reference())) || 
      ((ctx instanceof AssignmentExpression) && Objects.equal(ref, this.ePackage.getAssignmentExpression_AssignVar()))) || 
      ((ctx instanceof TimeAmountOrRef) && Objects.equal(ref, this.ePackage.getTimeAmountOrRef_Ref())))) {
      return this.getIdReferenceScope(ctx);
    }
    return super.getScope(ctx, ref);
  }
  
  private IScope getIdReferenceScope(final EObject ctx) {
    final Program prog = EcoreUtil2.<Program>getContainerOfType(ctx, Program.class);
    final ru.iaie.reflex.reflex.Process proc = EcoreUtil2.<ru.iaie.reflex.reflex.Process>getContainerOfType(ctx, ru.iaie.reflex.reflex.Process.class);
    final ArrayList<EObject> candidates = new ArrayList<EObject>();
    final Function1<ru.iaie.reflex.reflex.Enum, EList<EnumMember>> _function = (ru.iaie.reflex.reflex.Enum it) -> {
      return it.getEnumMembers();
    };
    Iterables.<EObject>addAll(candidates, Iterables.<EObject>concat(ListExtensions.<ru.iaie.reflex.reflex.Enum, EList<EnumMember>>map(prog.getEnums(), _function)));
    candidates.addAll(prog.getConsts());
    candidates.addAll(prog.getGlobalVars());
    if ((proc != null)) {
      candidates.addAll(ReflexModelUtil.getDeclaredVariables(proc));
      candidates.addAll(ReflexModelUtil.getImportedVariables(proc));
    }
    return Scopes.scopeFor(candidates);
  }
}
