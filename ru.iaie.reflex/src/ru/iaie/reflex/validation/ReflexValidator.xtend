/*
 * generated by Xtext 2.20.0
 */
package ru.iaie.reflex.validation

import org.eclipse.xtext.validation.Check
import ru.iaie.reflex.reflex.ReflexPackage
import ru.iaie.reflex.reflex.SetStateStat
import ru.iaie.reflex.reflex.Process

import static extension ru.iaie.reflex.utils.ReflexModelUtil.*
import static extension ru.iaie.reflex.utils.ExpressionUtil.*
import static extension org.eclipse.xtext.EcoreUtil2.*
import ru.iaie.reflex.reflex.ErrorStat
import ru.iaie.reflex.reflex.StopProcStat
import ru.iaie.reflex.reflex.StartProcStat
import ru.iaie.reflex.reflex.AssignmentExpression
import ru.iaie.reflex.reflex.PhysicalVariable
import ru.iaie.reflex.reflex.RegisterType
import ru.iaie.reflex.reflex.Program
import ru.iaie.reflex.reflex.TimeoutFunction
import ru.iaie.reflex.reflex.ProgramVariable
import ru.iaie.reflex.reflex.Const
import ru.iaie.reflex.reflex.EnumMember
import org.eclipse.emf.ecore.EObject
import java.util.Map
import ru.iaie.reflex.reflex.GlobalVariable
import ru.iaie.reflex.reflex.Register
import ru.iaie.reflex.reflex.ImportedVariableList
import static java.util.function.Function.identity;
import ru.iaie.reflex.reflex.DeclaredVariable

/** 
 * This class contains custom validation rules. 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ReflexValidator extends AbstractReflexValidator {

	static ReflexPackage ePackage = ReflexPackage.eINSTANCE

	@Check def void checkForNextState(SetStateStat setStateStat) {
		if (setStateStat.isNext()) {
			val state = setStateStat.getContainerOfType(ru.iaie.reflex.reflex.State)
			val process = setStateStat.getContainerOfType(Process)
			val callingStateIndex = process.states.indexOf(state)
			if (callingStateIndex + 1 >= process.states.length) {
				error("Invalid state transition: no next state in the process", ePackage.setStateStat_Next)
			}
		}
	}

	@Check def void checkStateTransitions(ru.iaie.reflex.reflex.State state) {
		if(state.isLooped) return;
		val stateTransitions = state.eAllContents.filter(SetStateStat)
		if (stateTransitions.isEmpty) {
			val selfStopTransitions = state.eAllContents.filter(StopProcStat).filter[selfStop]
			if (selfStopTransitions.isEmpty) {
				val selfErrorTransitions = state.eAllContents.filter(ErrorStat).filter[selfError]
				if (selfErrorTransitions.isEmpty) {
					error('''Potential cycle in state «state.name»: no state transitions declared''',
						ePackage.state_Name)
				}
			}
		}
	}

	@Check def void checkStartStatement(StartProcStat startStat) {
		val selfProcess = startStat.getContainerOfType(Process)
		val procName = startStat.process.name;
		if (selfProcess.name.equals(procName)) {
			warning('''Use 'restart' statement for restarting current process''', ePackage.startProcStat_Process)
		}
	}

	@Check def void checkStopStatement(StopProcStat stopStat) {
		val selfProcess = stopStat.getContainerOfType(Process)
		val procName = stopStat.process.name;
		if (selfProcess.name.equals(procName)) {
			warning('''Use 'stop' without argument to stop current process''', ePackage.stopProcStat_Process)
		}
	}

	@Check def void checkErrorStatement(ErrorStat errorStat) {
		val selfProcess = errorStat.getContainerOfType(Process)
		val procName = errorStat.process.name;
		if (selfProcess.name.equals(procName)) {
			warning("Use 'error' without argument to set current process state to error", ePackage.errorStat_Process)
		}
	}

	@Check def void checkAssignVariable(AssignmentExpression expr) {
		if (expr.hasAssignment) {
			val assignVar = expr.assignVar
			if (assignVar instanceof PhysicalVariable) {
				if (assignVar.mappedPortType == RegisterType.INPUT) {
					warning("An attempt to assign value into variable mapped on input port",
						ePackage.assignmentExpression_AssignVar);
				}
			}
			if (assignVar instanceof Const || assignVar instanceof EnumMember) {
				error("Can't assign values to constants or enum members", ePackage.assignmentExpression_AssignVar)
			}
		}
	}

	@Check def void checkOutputVarUsagesInAssignment(PhysicalVariable physVar) {
		if (physVar.mappedPortType == RegisterType.OUTPUT) {
			val program = physVar.getContainerOfType(Program)
			var usedInAssignment = program.containsReferencesOfType(physVar, ePackage.assignmentExpression_AssignVar)

			if (!usedInAssignment) {
				warning("Variable mapped on output port is not used in assignment", ePackage.physicalVariable_Name)
			}
		}
	}

	@Check def void checkStateReachability(ru.iaie.reflex.reflex.State state) {
		val process = state.getContainerOfType(Process)
		var curStateIndex = process.states.indexOf(state)
		if(curStateIndex == 0) return
		var transitionExists = process.containsReferencesOfType(state, ePackage.setStateStat_State)
		if (!transitionExists) {
			// Try check in previous state
			val prevState = process.states.get(curStateIndex - 1)
			val nextStateTransitions = prevState.eAllOfType(SetStateStat).filter[isNext]
			transitionExists = transitionExists || !nextStateTransitions.empty
		}
		if (!transitionExists) {
			warning("State is unreachable", ePackage.state_Name)
		}
	}

	@Check def void checkTimeoutVariable(TimeoutFunction func) {
		if (func.isReferencedTimeout) {
			val program = func.getContainerOfType(Program)
			val timeContainer = func.ref
			if (timeContainer instanceof ProgramVariable) {
				if (!program.containsReferencesOfType(timeContainer, ePackage.assignmentExpression_AssignVar)) {
					warning("Uninitialized variable is used in timeout", ePackage.timeAmountOrRef_Ref)
				}
			}
		}
	}

	@Check def void checkNameShadowing(Process process) {
		val Map<String, EObject> globalCtx = newHashMap()

		val program = process.getContainerOfType(Program)
		globalCtx.putAll(program.globalVars.toMap([name], identity))
		globalCtx.putAll(program.registers.toMap([name], identity))
		globalCtx.putAll(program.enums.map[enumMembers].flatten.toMap([name], identity))
		globalCtx.putAll(program.consts.toMap([name], identity))

		for (variable : process.declaredVariables) {
			var ref = variable.isPhysical ? ePackage.physicalVariable_Name : ePackage.programVariable_Name
			if (globalCtx.containsKey(variable.name)) {
				var shadowed = globalCtx.get(variable.name)
				var String errorMessage
				switch shadowed {
					GlobalVariable:
						errorMessage = '''Process variable shadows global variable with name "«shadowed.name»"'''
					Register:
						errorMessage = '''Process variable shadows port with name "«shadowed.name»"'''
					EnumMember:
						errorMessage = '''Process variable shadows enum member with name "«shadowed.name»"'''
					Const:
						errorMessage = '''Process variable shadows constant with name "«shadowed.name»"'''
				}
				error(errorMessage, variable, ref)
			}
		}
	}

	@Check def void checkImportedVariablesConflictsProcessVariables(ImportedVariableList imports) {
		val Map<String, DeclaredVariable> ctx = imports.getContainerOfType(Process).declaredVariables.toMap([name],
			identity);
		for (variable : imports.variables) {
			if (ctx.containsKey(variable.name)) {
				var conflicted = ctx.get(variable.name)
				var ref = conflicted.isPhysical ? ePackage.physicalVariable_Name : ePackage.programVariable_Name
				error("Process variable conflicts with imported variable", conflicted, ref)
				error('''Name "«variable.name»" conflicts with process variable name''',
					ePackage.importedVariableList_Variables)
			}
		}
	}

	@Check def void checkImportedVariablesConflictsOtherImports(ImportedVariableList importToCheck) {
		var Map<String, ImportedVariableList> ctx = newHashMap()
		for (imp : importToCheck.getContainerOfType(Process).imports.reject[equals(importToCheck)]) {
			for (variable : imp.variables) {
				ctx.put(variable.name, imp)
			}
		}

		for (variable : importToCheck.variables) {
			if (ctx.containsKey(variable.name)) {
				var conflicted = ctx.get(variable.name)
				error('''Conflict for name «variable.name» in imports''', conflicted,
					ePackage.importedVariableList_Variables)
				error('''Conflict for name «variable.name» in imports''', importToCheck,
					ePackage.importedVariableList_Variables)

			}
		}
	}

}
