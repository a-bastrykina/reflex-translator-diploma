grammar ru.iaie.reflex.Reflex with org.eclipse.xtext.common.Terminals

generate reflex "http://www.iaie.ru/reflex/Reflex"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Program:
	("[" annotations+=Annotation "]")*
	"program" name=ID "{"
	(ticks=Tact)?
	(consts+=Const |
	enums+=Enum |
	functions+=Function |
	globalVars+=GlobalVariable |
	registers+=Register |
	processes+=Process)*
	"}";

Tact:
	"clock" value=INTEGER ";";

Process:
	("[" annotations+=Annotation "]")*
	"process" name=ID "{"
	(variables+=ProcessVariable)*
	states+=State*
	"}";

State:
	("[" annotations+=Annotation "]")*
	"state" name=ID (looped?="looped")? "{"
	stateFunction=StatementSequence
	(timeoutFunction=TimeoutFunction)?
	"}";

ProcessVariable:
	(ImportedVariableList | DeclaredVariable) ";";

ImportedVariableList:
	"shared" (variables+=[DeclaredVariable] ("," variables+=[DeclaredVariable])*) "from" "process" process=[Process];

DeclaredVariable:
	(PhysicalVariable | ProgramVariable) (shared?="shared")?;

GlobalVariable:
	(PhysicalVariable | ProgramVariable) ";";

PhysicalVariable:
	type=Type name=ID "=" port=RegisterPortMapping;

RegisterPortMapping:
	register=[Register] ("[" portBit=INTEGER "]")?;

ProgramVariable:
	type=Type name=ID;

StatementSequence:
	{StatementSequence} statements+=Statement*;

CompoundStatement:
	{StatementBlock} "{" statements+=Statement* "}";

TimeoutFunction:
	"timeout" (TimeAmountOrRef | "(" TimeAmountOrRef ")") body=Statement;

fragment TimeAmountOrRef:
	time=Time | ref=[IdReference];

Statement:
	{Statement} ";" | CompoundStatement |
	StartProcStat | StopProcStat | ErrorStat | RestartStat | ResetStat
	| SetStateStat | IfElseStat | SwitchStat | Expression ";";

IfElseStat:
	"if" "(" cond=Expression ")"
	then=Statement
	(=> "else" else=Statement)?;

SwitchStat:
	"switch" "(" expr=Expression ")" "{" options+=CaseStat* "}";

CaseStat:
	"case" option=INTEGER ":" body=StatementSequence hasBreak?=BreakStat "}";

BreakStat:
	"break" ";";

StartProcStat:
	"start" "process" process=[Process] ";";

StopProcStat:
	{StopProcStat} "stop" ("process" (process=[Process]))? ";";

ErrorStat:
	{ErrorStat} "error" ("process" (process=[Process]))? ";";

RestartStat:
	{RestartStat} "restart" ";";

ResetStat:
	{ResetStat} "reset" "timer" ";";

SetStateStat:
	{SetStateStat} "set" ((next?="next" "state") | ("state" state=[State])) ";";

Function:
	returnType=Type name=ID "(" argTypes+=Type ("," argTypes+=Type)* ")" ";";

enum RegisterType:
	INPUT='input' | OUTPUT='output';

Register:
	type=RegisterType name=ID addr1=INTEGER addr2=INTEGER regSize=INTEGER ";";

Const:
	"const" type=Type name=ID "=" constValue=Expression ";";

Enum:
	"enum" identifier=ID "{" enumMembers+=EnumMember (',' enumMembers+=EnumMember)* "}";

EnumMember:
	name=ID ("=" value=Expression)?;

InfixOp:
	op=InfixPostfixOp varId=ID;

PostfixOp:
	varId=ID op=InfixPostfixOp;

FunctionCall:
	function=[Function] "(" (args+=Expression ("," args+=Expression)*)? ")";

IdReference:
	PhysicalVariable | ProgramVariable | EnumMember | Const;

CheckStateExpression:
	"process" process=[Process] "in" "state" qualfier=StateQualifier;

enum StateQualifier:
	ACTIVE="active" | INACTIVE="inactive" | STOP="stop" | ERROR="error";

PrimaryExpression:
	reference=[IdReference] | {PrimaryExpression} integer=INTEGER | {PrimaryExpression} floating=FLOAT |
	{PrimaryExpression} bool=BoolLiteral | "(" nestedExpr=Expression ")";

UnaryExpression:
	PrimaryExpression |
	FunctionCall |
	PostfixOp |
	InfixOp |
	unaryOp=UnaryOp right=CastExpression;

CastExpression:
	UnaryExpression |
	"(" type=Type ")" right=CastExpression;

MultiplicativeExpression:
	CastExpression ({MultiplicativeExpression.left=current} mulOp=MultiplicativeOp right=CastExpression)*;

AdditiveExpression:
	MultiplicativeExpression ({AdditiveExpression.left=current} addOp=AdditiveOp right=AdditiveExpression)*;

ShiftExpression:
	AdditiveExpression ({ShiftExpression.left=current} shiftOp=ShiftOp right=ShiftExpression)*;

CompareExpression:
	CheckStateExpression | ShiftExpression ({CompareExpression.left=current} cmpOp=CompareOp right=CompareExpression)*;

EqualityExpression:
	CompareExpression ({EqualityExpression.left=current} eqCmpOp=CompareEqOp right=EqualityExpression)*;

BitAndExpression:
	EqualityExpression ({BitAndExpression.left=current} BIT_AND right=BitAndExpression)*;

BitXorExpression:
	BitAndExpression ({BitXorExpression.left=current} BIT_XOR right=BitXorExpression)*;

BitOrExpression:
	BitXorExpression ({BitOrExpression.left=current} BIT_OR right=BitOrExpression)*;

LogicalAndExpression:
	BitOrExpression ({LogicalAndExpression.left=current} LOGICAL_AND right=LogicalAndExpression)*;

LogicalOrExpression:
	LogicalAndExpression ({LogicalOrExpression.left=current} LOGICAL_OR right=LogicalOrExpression)*;

AssignmentExpression:
	(assignVar=[IdReference] assignOp=AssignOperator)? expr=LogicalOrExpression;

Expression:
	AssignmentExpression;

enum InfixPostfixOp:
	INC="++" | DEC="--";

enum AssignOperator:
	ASSIGN="=" | MUL='*=' | DIV="/=" | MOD="+=" | SUB="-=" | CIN="<<=" | COUT=">>=" | BIT_AND="&=" | BIT_XOR="^=" |
	BIT_OR="|=";

enum UnaryOp:
	PLUS="+" | MINUS="-" | BIT_NOT="~" | LOGICAL_NOT="!";

enum CompareOp:
	LESS="<" | GREATER=">" | LESS_EQ="=<" | GREATER_EQ=">=";

enum CompareEqOp:
	EQ="==" | NOT_EQ="!=";

enum ShiftOp:
	LEFT_SHIFT=">>" | RIGHT_SHIFT="<<";

enum AdditiveOp:
	PLUS="+" | MINUS="-";

enum MultiplicativeOp:
	MUL="*" | DIV="/" | MOD="%";

enum BoolLiteral:
	TRUE="true" | FALSE="false";

Type:
	(sign=TypeSignSpec)? name=Types;

enum Types:
	VOID_C_TYPE="void" | FLOAT_C_TYPE="float" | DOUBLE_C_TYPE="double" | SHORT_C_TYPE="short" | INT_C_TYPE="int" |
	LONG_C_TYPE="long" | BOOL_TYPE="bool";

enum TypeSignSpec:
	SIGNED="signed" | UNSIGNED="unsigned";

terminal LOGICAL_OR:
	"||";

terminal LOGICAL_AND:
	"&&";

terminal BIT_OR:
	"|";

terminal BIT_XOR:
	"^";

terminal BIT_AND:
	"&";

	// LITERALS
terminal INTEGER:
	(HEX | OCTAL | DECIMAL) (LONG | UNSIGNED)?;

terminal FLOAT:
	DEC_FLOAT | HEX_FLOAT;

terminal fragment DEC_FLOAT:
	DEC_SEQUENCE? '.' DEC_SEQUENCE (EXPONENT SIGN DEC_SEQUENCE)? (LONG | FLOAT_SUFFIX)?;

terminal fragment HEX_FLOAT:
	HEX_SEQUENCE? '.' HEX_SEQUENCE (BIN_EXPONENT SIGN DEC_SEQUENCE)? (LONG | FLOAT_SUFFIX)?;

terminal fragment DEC_SEQUENCE:
	('0'..'9')+;

terminal fragment HEX_SEQUENCE:
	('0'..'9' | 'a'..'f' | 'A'..'F')+;

terminal fragment BIN_EXPONENT:
	('p' | 'P');

terminal fragment EXPONENT:
	'e' | 'E';

terminal fragment SIGN:
	'+' | '-';

terminal fragment DECIMAL:
	"0" | ('1'..'9') ('0'..'9')*;

terminal fragment OCTAL:
	'0' ('0'..'7')+;

terminal fragment HEX:
	HEX_PREFIX HEX_SEQUENCE;

terminal fragment HEX_PREFIX:
	'0' ('x' | 'X');

Time:
	ticks=INTEGER;

terminal fragment LONG:
	"L" | "l";

terminal fragment FLOAT_SUFFIX:
	"F" | "f";

terminal fragment UNSIGNED:
	"U" | "u";

Annotation:
	key=AnnotationKey ":" value=STRING | key=AnnotationKey;

AnnotationKey:
	ID "." ID | ID;

//	{Time} ("0t" | "0T") (isDay?=DAY (days=DECIMAL))? (isHour?=HOUR (hours=DECIMAL))?; //(MINUTE minutes=DECIMAL)?(SECOND seconds=DECIMAL)?(MILISECOND milis=DECIMAL)?(MICROSECOND micros=DECIMAL)?(NANOSECOND nanos=DECIMAL)?;
//terminal fragment DAY:
//	"D" | "d";
//
//terminal fragment HOUR:
//	"H" | "h";
//
//terminal fragment MINUTE:
//	"M" | "m";
//
//terminal fragment SECOND:
//	"S" | "s";
//
//terminal fragment MILISECOND:
//	"MS" | "ms";
//
//terminal fragment MICROSECOND:
//	"US" | "us";
//
//terminal fragment NANOSECOND:
//	"NS" | "ns";