grammar ru.iaie.reflex.Reflex with org.eclipse.xtext.common.Terminals

generate reflex "http://www.iaie.ru/reflex/Reflex"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Program:
	"program" name=ID "{"
	(ticks?=TACT)?
	(consts+=Const |
	enums+=Enum |
	functions+=Function |
	registers+=Register |
	processes+=Process)*
	"}";

Process:
	"proc" name=ID "{"
	variable+=Variable*
	states+=State*
	"}";

	// Variables
Variable:
	ImportedVariable | DeclaredVariable ";";

ImportedVariable:
	"from" "proc" procId=ID varNames+=ID*;

DeclaredVariable:
	(PhysicalVariable | ProgramVariable) visibility=Visibility;

PhysicalVariable:
	type=IntegerType name=ID "=" "{" ports+=RegisterPort ("," ports+=RegisterPort)* "}";

RegisterPort:
	regName=ID "[" port=Integer "]";

ProgramVariable:
	type=ReflexType name=ID;

Visibility:
	LOCAL="local" | GLOBAL="global" | SHARED="shared" sharingProcs+=ID*;

State:
	"state" name=ID "{"
	(stateFunction=StateFunction)?
	(timeoutFunction=TimeoutFunction)?
	"}";

StateFunction:
	body=Body;

TimeoutFunction:
	"timeout" time=Time body=Body;

Body:
	{Body} ";" | {Body} ("{" sub+=Body* "}") | statements+=IfElseStat |
	statements+=SwitchStat | statements+=StartProcStat | statements+=StopProcStat |
	statements+=ErrorStat | loop?=LoopStat |
	restart?=RestartStat | statements+=SetStateStat | statements+=Expression ";";

AssignStat:
	varId=ID "=" expr=Expression ";";

IfElseStat:
	"if" "(" cond=Expression ")"
	then=Body
	(=> "else" else=Body)?;

SwitchStat:
	"switch" "(" expr=Expression ")" "{" options+=CaseStat* "}";

	//TODO: add flag for break statement absence
CaseStat:
	"case" option=Integer ":" body=Body ("break" ";");

StartProcStat:
	"start" procId=ID ";";

StopProcStat:
	{StopProcStat} "stop" (procId?=ID)? ";";

ErrorStat:
	{ErrorStat} "error" (procId?=ID)? ";";

LoopStat:
	"loop" ";";

RestartStat:
	"restart" ";";

ResetStat:
	"reset" "timeout" ";";
	//TODO: add flag to identify if next
SetStateStat:
	{SetStateStat} "set" (("state" stateId=ID) | "next") ";";

Function:
	returnType=CType name=ID "(" argTypes+=CType ("," argTypes+=CType)* ")" ";";

enum RegisterType:
	INPUT='input' | OUTPUT='output';

Register:
	type=RegisterType name=ID addr1=Integer addr2=Integer regSize=REG_SIZE ";";

Const:
	"const" constId=ID constValue=Expression ";";

Enum:
	"enum" enumMembers+=EnumMember (',' enumMembers+=EnumMember)* ";";

EnumMember:
	name=ID "=" value=Expression;

	// Expression	
InfixOp:
	op=InfixPostfixOp varId=ID;

PostfixOp:
	varId=ID op=InfixPostfixOp;

FunctionCall:
	funcId=ID "(" args+=Expression ("," args+=Expression)* ")";

PrimaryExpression:
	varId=ID | literal=Integer | "(" expr=Expression ")";

UnaryExpression:
	PrimaryExpression |
	FunctionCall |
	PostfixOp |
	InfixOp |
	unaryOp=UnaryOp rest=CastExpression;

CastExpression:
	UnaryExpression |
	"(" type=ReflexType ")" right=CastExpression;

MultiplicativeExpression:
	CastExpression ({MultiplicativeExpression.left=current} mulOp=MultiplicativeOp right=CastExpression)*;

AdditiveExpression:
	MultiplicativeExpression ({AdditiveExpression.left=current} addOp=AdditiveOp rightt=AdditiveExpression)*;

ShiftExpression:
	AdditiveExpression ({ShiftExpression.left=current} shiftOp=ShiftOp right=ShiftExpression)*;

CompareExpression:
	ShiftExpression ({CompareExpression.left=current} cmpOp=CompareOp right=CompareExpression)*;

EqualityExpression:
	CompareExpression ({EqualityExpression.left=current} eqCmpOp=CompareEqOp right=EqualityExpression)*;

BitAndExpression:
	EqualityExpression ({BitAndExpression.left=current} BIT_AND right=BitAndExpression)*;

BitXorExpression:
	BitAndExpression ({BitXorExpression.left=current} BIT_XOR right=BitXorExpression)*;

BitOrExpression:
	BitXorExpression ({BitOrExpression.left=current} BIT_OR right=BitOrExpression)*;

LogicalAndExpression:
	BitOrExpression ({LogicalAndExpression.left=current} LOGICAL_AND right=LogicalAndExpression)*;

LogicalOrExpression:
	LogicalAndExpression ({LogicalOrExpression.left=current} LOGICAL_OR right=LogicalOrExpression)*;

AssignmentExpression:
	LogicalOrExpression |
	assignVar?=ID assignOp?=AssignOperator expr=LogicalOrExpression;
	
Expression:
	AssignmentExpression
;

enum InfixPostfixOp:
	INC="++" | DEC="--";

enum AssignOperator:
	ASSIGN="=" | MUL='*=' | DIV="/=" | MOD="+=" | SUB="-=" | CIN="<<=" | COUT=">>=" | BIT_AND="&=" | BIT_XOR="^=" |
	BIT_OR="|=";

enum UnaryOp:
	PLUS="+" | MINUS="-" | BIT_NOT="~" | LOGICAL_NOT="!";

enum CompareOp:
	LESS="<" | GREATER=">" | LESS_EQ="=<" | GREATER_EQ=">=";

enum CompareEqOp:
	EQ="==" | NOT_EQ="!=";

enum ShiftOp:
	LEFT_SHIFT=">>" | RIGHT_SHIFT="<<";

enum AdditiveOp:
	PLUS="+" | MINUS="-";

enum MultiplicativeOp:
	MUL="*" | DIV="/" | MOD="%";

CType:
	{CType} VOID_C_TYPE | {CType} FLOAT_C_TYPE | {CType} DOUBLE_C_TYPE | {CType} (signSpec?=CTypeSignSpec)? (SHORT_C_TYPE
	| INT_C_TYPE | LONG_C_TYPE);

enum CTypeSignSpec:
	SIGNED="signed" | UNSIGNED="unsigned";

IntegerType:
	BOOL_TYPE | INT_C_TYPE | SHORT_C_TYPE | LONG_C_TYPE;

ReflexType:
	CType | {ReflexType} BOOL_TYPE;

terminal LOGICAL_OR:
	"||";

terminal LOGICAL_AND:
	"&&";

terminal BIT_OR:
	"|";

terminal BIT_XOR:
	"^";

terminal BIT_AND:
	"&";

	// TODO: move to another file
terminal VOID_C_TYPE:
	"void";

terminal FLOAT_C_TYPE:
	"float";

terminal DOUBLE_C_TYPE:
	"double";

terminal SHORT_C_TYPE:
	"short";

terminal INT_C_TYPE:
	"int";

terminal LONG_C_TYPE:
	"long";

terminal BOOL_TYPE:
	"bool";

terminal TACT:
	"tact";

	// LITERALS
Integer:
	value=(DECIMAL | OCTAL | HEX) qualfier?=(LONG | UNSIGNED)?;

terminal REG_SIZE returns ecore::EInt:
	("8" | "16");

terminal DECIMAL:
	('1'..'9') ('0'..'9')*;

terminal OCTAL:
	'0' ('0'..'7')*;

terminal HEX:
	'0' ('x' | 'X') ('0'..'9' | 'a'..'f' | 'A'..'F')+;

	// Time
Time:
	{Time} ("0t" | "0T") (DAY days=DECIMAL)? (HOUR hours=DECIMAL)? (MINUTE minutes=DECIMAL)? (SECOND seconds=DECIMAL)?
	(MILISECOND milis=DECIMAL)? (MICROSECOND micros=DECIMAL)? (NANOSECOND nanos=DECIMAL)?;

terminal LONG:
	"L" | "l";

terminal UNSIGNED:
	"U" | "u";

terminal DAY:
	"D" | "d";

terminal HOUR:
	"H" | "h";

terminal MINUTE:
	"M" | "m";

terminal SECOND:
	"S" | "s";

terminal MILISECOND:
	"MS" | "ms";

terminal MICROSECOND:
	"US" | "us";

terminal NANOSECOND:
	"NS" | "ns";