/*
 * generated by Xtext 2.20.0
 */
package ru.iaie.reflex.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import ru.iaie.reflex.reflex.AdditiveExpression;
import ru.iaie.reflex.reflex.Annotation;
import ru.iaie.reflex.reflex.AssignmentExpression;
import ru.iaie.reflex.reflex.BitAndExpression;
import ru.iaie.reflex.reflex.BitOrExpression;
import ru.iaie.reflex.reflex.BitXorExpression;
import ru.iaie.reflex.reflex.CType;
import ru.iaie.reflex.reflex.CaseStat;
import ru.iaie.reflex.reflex.CastExpression;
import ru.iaie.reflex.reflex.CheckStateExpression;
import ru.iaie.reflex.reflex.CompareExpression;
import ru.iaie.reflex.reflex.Const;
import ru.iaie.reflex.reflex.EnumMember;
import ru.iaie.reflex.reflex.EqualityExpression;
import ru.iaie.reflex.reflex.ErrorStat;
import ru.iaie.reflex.reflex.Function;
import ru.iaie.reflex.reflex.FunctionCall;
import ru.iaie.reflex.reflex.IfElseStat;
import ru.iaie.reflex.reflex.ImportedVariable;
import ru.iaie.reflex.reflex.InfixOp;
import ru.iaie.reflex.reflex.LogicalAndExpression;
import ru.iaie.reflex.reflex.LogicalOrExpression;
import ru.iaie.reflex.reflex.MultiplicativeExpression;
import ru.iaie.reflex.reflex.PhysicalVariable;
import ru.iaie.reflex.reflex.PostfixOp;
import ru.iaie.reflex.reflex.PrimaryExpression;
import ru.iaie.reflex.reflex.Program;
import ru.iaie.reflex.reflex.ProgramVariable;
import ru.iaie.reflex.reflex.ReflexPackage;
import ru.iaie.reflex.reflex.ReflexType;
import ru.iaie.reflex.reflex.Register;
import ru.iaie.reflex.reflex.RegisterPortMapping;
import ru.iaie.reflex.reflex.ResetStat;
import ru.iaie.reflex.reflex.RestartStat;
import ru.iaie.reflex.reflex.SetStateStat;
import ru.iaie.reflex.reflex.ShiftExpression;
import ru.iaie.reflex.reflex.StartProcStat;
import ru.iaie.reflex.reflex.State;
import ru.iaie.reflex.reflex.Statement;
import ru.iaie.reflex.reflex.StatementBlock;
import ru.iaie.reflex.reflex.StatementSequence;
import ru.iaie.reflex.reflex.StopProcStat;
import ru.iaie.reflex.reflex.SwitchStat;
import ru.iaie.reflex.reflex.Tact;
import ru.iaie.reflex.reflex.Time;
import ru.iaie.reflex.reflex.TimeoutFunction;
import ru.iaie.reflex.reflex.UnaryExpression;
import ru.iaie.reflex.services.ReflexGrammarAccess;

@SuppressWarnings("all")
public class ReflexSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ReflexGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ReflexPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ReflexPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case ReflexPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case ReflexPackage.ASSIGNMENT_EXPRESSION:
				sequence_AssignmentExpression(context, (AssignmentExpression) semanticObject); 
				return; 
			case ReflexPackage.BIT_AND_EXPRESSION:
				sequence_BitAndExpression(context, (BitAndExpression) semanticObject); 
				return; 
			case ReflexPackage.BIT_OR_EXPRESSION:
				sequence_BitOrExpression(context, (BitOrExpression) semanticObject); 
				return; 
			case ReflexPackage.BIT_XOR_EXPRESSION:
				sequence_BitXorExpression(context, (BitXorExpression) semanticObject); 
				return; 
			case ReflexPackage.CTYPE:
				sequence_CType(context, (CType) semanticObject); 
				return; 
			case ReflexPackage.CASE_STAT:
				sequence_CaseStat(context, (CaseStat) semanticObject); 
				return; 
			case ReflexPackage.CAST_EXPRESSION:
				sequence_CastExpression(context, (CastExpression) semanticObject); 
				return; 
			case ReflexPackage.CHECK_STATE_EXPRESSION:
				sequence_CheckStateExpression(context, (CheckStateExpression) semanticObject); 
				return; 
			case ReflexPackage.COMPARE_EXPRESSION:
				sequence_CompareExpression(context, (CompareExpression) semanticObject); 
				return; 
			case ReflexPackage.CONST:
				sequence_Const(context, (Const) semanticObject); 
				return; 
			case ReflexPackage.ENUM:
				sequence_Enum(context, (ru.iaie.reflex.reflex.Enum) semanticObject); 
				return; 
			case ReflexPackage.ENUM_MEMBER:
				sequence_EnumMember(context, (EnumMember) semanticObject); 
				return; 
			case ReflexPackage.EQUALITY_EXPRESSION:
				sequence_EqualityExpression(context, (EqualityExpression) semanticObject); 
				return; 
			case ReflexPackage.ERROR_STAT:
				sequence_ErrorStat(context, (ErrorStat) semanticObject); 
				return; 
			case ReflexPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case ReflexPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case ReflexPackage.IF_ELSE_STAT:
				sequence_IfElseStat(context, (IfElseStat) semanticObject); 
				return; 
			case ReflexPackage.IMPORTED_VARIABLE:
				sequence_ImportedVariable(context, (ImportedVariable) semanticObject); 
				return; 
			case ReflexPackage.INFIX_OP:
				sequence_InfixOp(context, (InfixOp) semanticObject); 
				return; 
			case ReflexPackage.LOGICAL_AND_EXPRESSION:
				sequence_LogicalAndExpression(context, (LogicalAndExpression) semanticObject); 
				return; 
			case ReflexPackage.LOGICAL_OR_EXPRESSION:
				sequence_LogicalOrExpression(context, (LogicalOrExpression) semanticObject); 
				return; 
			case ReflexPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case ReflexPackage.PHYSICAL_VARIABLE:
				if (rule == grammarAccess.getProcessVariableRule()
						|| rule == grammarAccess.getDeclaredVariableRule()
						|| rule == grammarAccess.getIdReferenceRule()) {
					sequence_DeclaredVariable_PhysicalVariable(context, (PhysicalVariable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getGlobalVariableRule()
						|| rule == grammarAccess.getPhysicalVariableRule()) {
					sequence_PhysicalVariable(context, (PhysicalVariable) semanticObject); 
					return; 
				}
				else break;
			case ReflexPackage.POSTFIX_OP:
				sequence_PostfixOp(context, (PostfixOp) semanticObject); 
				return; 
			case ReflexPackage.PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
				return; 
			case ReflexPackage.PROCESS:
				sequence_Process(context, (ru.iaie.reflex.reflex.Process) semanticObject); 
				return; 
			case ReflexPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case ReflexPackage.PROGRAM_VARIABLE:
				if (rule == grammarAccess.getProcessVariableRule()
						|| rule == grammarAccess.getDeclaredVariableRule()
						|| rule == grammarAccess.getIdReferenceRule()) {
					sequence_DeclaredVariable_ProgramVariable(context, (ProgramVariable) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getGlobalVariableRule()
						|| rule == grammarAccess.getProgramVariableRule()) {
					sequence_ProgramVariable(context, (ProgramVariable) semanticObject); 
					return; 
				}
				else break;
			case ReflexPackage.REFLEX_TYPE:
				sequence_ReflexType(context, (ReflexType) semanticObject); 
				return; 
			case ReflexPackage.REGISTER:
				sequence_Register(context, (Register) semanticObject); 
				return; 
			case ReflexPackage.REGISTER_PORT_MAPPING:
				sequence_RegisterPortMapping(context, (RegisterPortMapping) semanticObject); 
				return; 
			case ReflexPackage.RESET_STAT:
				sequence_ResetStat(context, (ResetStat) semanticObject); 
				return; 
			case ReflexPackage.RESTART_STAT:
				sequence_RestartStat(context, (RestartStat) semanticObject); 
				return; 
			case ReflexPackage.SET_STATE_STAT:
				sequence_SetStateStat(context, (SetStateStat) semanticObject); 
				return; 
			case ReflexPackage.SHIFT_EXPRESSION:
				sequence_ShiftExpression(context, (ShiftExpression) semanticObject); 
				return; 
			case ReflexPackage.START_PROC_STAT:
				sequence_StartProcStat(context, (StartProcStat) semanticObject); 
				return; 
			case ReflexPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case ReflexPackage.STATEMENT:
				sequence_Statement(context, (Statement) semanticObject); 
				return; 
			case ReflexPackage.STATEMENT_BLOCK:
				sequence_CompoundStatement(context, (StatementBlock) semanticObject); 
				return; 
			case ReflexPackage.STATEMENT_SEQUENCE:
				sequence_StatementSequence(context, (StatementSequence) semanticObject); 
				return; 
			case ReflexPackage.STOP_PROC_STAT:
				sequence_StopProcStat(context, (StopProcStat) semanticObject); 
				return; 
			case ReflexPackage.SWITCH_STAT:
				sequence_SwitchStat(context, (SwitchStat) semanticObject); 
				return; 
			case ReflexPackage.TACT:
				sequence_Tact(context, (Tact) semanticObject); 
				return; 
			case ReflexPackage.TIME:
				sequence_Time(context, (Time) semanticObject); 
				return; 
			case ReflexPackage.TIMEOUT_FUNCTION:
				sequence_TimeAmountOrRef_TimeoutFunction(context, (TimeoutFunction) semanticObject); 
				return; 
			case ReflexPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AdditiveExpression returns AdditiveExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns AdditiveExpression
	 *     ShiftExpression returns AdditiveExpression
	 *     ShiftExpression.ShiftExpression_1_0 returns AdditiveExpression
	 *     CompareExpression returns AdditiveExpression
	 *     CompareExpression.CompareExpression_1_1_0 returns AdditiveExpression
	 *     EqualityExpression returns AdditiveExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns AdditiveExpression
	 *     BitAndExpression returns AdditiveExpression
	 *     BitAndExpression.BitAndExpression_1_0 returns AdditiveExpression
	 *     BitXorExpression returns AdditiveExpression
	 *     BitXorExpression.BitXorExpression_1_0 returns AdditiveExpression
	 *     BitOrExpression returns AdditiveExpression
	 *     BitOrExpression.BitOrExpression_1_0 returns AdditiveExpression
	 *     LogicalAndExpression returns AdditiveExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns AdditiveExpression
	 *     LogicalOrExpression returns AdditiveExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns AdditiveExpression
	 *
	 * Constraint:
	 *     (left=AdditiveExpression_AdditiveExpression_1_0 addOp=AdditiveOp right=AdditiveExpression)
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, AdditiveExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.ADDITIVE_EXPRESSION__ADD_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.ADDITIVE_EXPRESSION__ADD_OP));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getAdditiveExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getAddOpAdditiveOpEnumRuleCall_1_1_0(), semanticObject.getAddOp());
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getRightAdditiveExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Annotation returns Annotation
	 *
	 * Constraint:
	 *     ((key=AnnotationKey value=STRING) | key=AnnotationKey)
	 */
	protected void sequence_Annotation(ISerializationContext context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns AssignmentExpression
	 *     AssignmentExpression returns AssignmentExpression
	 *     Expression returns AssignmentExpression
	 *
	 * Constraint:
	 *     ((assignVar=ID assignOp=AssignOperator)? expr=LogicalOrExpression)
	 */
	protected void sequence_AssignmentExpression(ISerializationContext context, AssignmentExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BitAndExpression returns BitAndExpression
	 *     BitAndExpression.BitAndExpression_1_0 returns BitAndExpression
	 *     BitXorExpression returns BitAndExpression
	 *     BitXorExpression.BitXorExpression_1_0 returns BitAndExpression
	 *     BitOrExpression returns BitAndExpression
	 *     BitOrExpression.BitOrExpression_1_0 returns BitAndExpression
	 *     LogicalAndExpression returns BitAndExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns BitAndExpression
	 *     LogicalOrExpression returns BitAndExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns BitAndExpression
	 *
	 * Constraint:
	 *     (left=BitAndExpression_BitAndExpression_1_0 right=BitAndExpression)
	 */
	protected void sequence_BitAndExpression(ISerializationContext context, BitAndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitAndExpressionAccess().getBitAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitAndExpressionAccess().getRightBitAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BitOrExpression returns BitOrExpression
	 *     BitOrExpression.BitOrExpression_1_0 returns BitOrExpression
	 *     LogicalAndExpression returns BitOrExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns BitOrExpression
	 *     LogicalOrExpression returns BitOrExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns BitOrExpression
	 *
	 * Constraint:
	 *     (left=BitOrExpression_BitOrExpression_1_0 right=BitOrExpression)
	 */
	protected void sequence_BitOrExpression(ISerializationContext context, BitOrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitOrExpressionAccess().getBitOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitOrExpressionAccess().getRightBitOrExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BitXorExpression returns BitXorExpression
	 *     BitXorExpression.BitXorExpression_1_0 returns BitXorExpression
	 *     BitOrExpression returns BitXorExpression
	 *     BitOrExpression.BitOrExpression_1_0 returns BitXorExpression
	 *     LogicalAndExpression returns BitXorExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns BitXorExpression
	 *     LogicalOrExpression returns BitXorExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns BitXorExpression
	 *
	 * Constraint:
	 *     (left=BitXorExpression_BitXorExpression_1_0 right=BitXorExpression)
	 */
	protected void sequence_BitXorExpression(ISerializationContext context, BitXorExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitXorExpressionAccess().getBitXorExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitXorExpressionAccess().getRightBitXorExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CType returns CType
	 *     ReflexType returns CType
	 *
	 * Constraint:
	 *     signSpec?=CTypeSignSpec?
	 */
	protected void sequence_CType(ISerializationContext context, CType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CaseStat returns CaseStat
	 *
	 * Constraint:
	 *     (option=INTEGER body=StatementSequence hasBreak?=BreakStat)
	 */
	protected void sequence_CaseStat(ISerializationContext context, CaseStat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.CASE_STAT__OPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.CASE_STAT__OPTION));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.CASE_STAT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.CASE_STAT__BODY));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.CASE_STAT__HAS_BREAK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.CASE_STAT__HAS_BREAK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCaseStatAccess().getOptionINTEGERTerminalRuleCall_1_0(), semanticObject.getOption());
		feeder.accept(grammarAccess.getCaseStatAccess().getBodyStatementSequenceParserRuleCall_3_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getCaseStatAccess().getHasBreakBreakStatParserRuleCall_4_0(), semanticObject.isHasBreak());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CastExpression returns CastExpression
	 *     MultiplicativeExpression returns CastExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns CastExpression
	 *     AdditiveExpression returns CastExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns CastExpression
	 *     ShiftExpression returns CastExpression
	 *     ShiftExpression.ShiftExpression_1_0 returns CastExpression
	 *     CompareExpression returns CastExpression
	 *     CompareExpression.CompareExpression_1_1_0 returns CastExpression
	 *     EqualityExpression returns CastExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns CastExpression
	 *     BitAndExpression returns CastExpression
	 *     BitAndExpression.BitAndExpression_1_0 returns CastExpression
	 *     BitXorExpression returns CastExpression
	 *     BitXorExpression.BitXorExpression_1_0 returns CastExpression
	 *     BitOrExpression returns CastExpression
	 *     BitOrExpression.BitOrExpression_1_0 returns CastExpression
	 *     LogicalAndExpression returns CastExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns CastExpression
	 *     LogicalOrExpression returns CastExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns CastExpression
	 *
	 * Constraint:
	 *     (type=ReflexType right=CastExpression)
	 */
	protected void sequence_CastExpression(ISerializationContext context, CastExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.CAST_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.CAST_EXPRESSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCastExpressionAccess().getTypeReflexTypeParserRuleCall_1_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getCastExpressionAccess().getRightCastExpressionParserRuleCall_1_3_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CheckStateExpression returns CheckStateExpression
	 *     CompareExpression returns CheckStateExpression
	 *     EqualityExpression returns CheckStateExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns CheckStateExpression
	 *     BitAndExpression returns CheckStateExpression
	 *     BitAndExpression.BitAndExpression_1_0 returns CheckStateExpression
	 *     BitXorExpression returns CheckStateExpression
	 *     BitXorExpression.BitXorExpression_1_0 returns CheckStateExpression
	 *     BitOrExpression returns CheckStateExpression
	 *     BitOrExpression.BitOrExpression_1_0 returns CheckStateExpression
	 *     LogicalAndExpression returns CheckStateExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns CheckStateExpression
	 *     LogicalOrExpression returns CheckStateExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns CheckStateExpression
	 *
	 * Constraint:
	 *     (process=[Process|ID] qualfier=StateQualifier)
	 */
	protected void sequence_CheckStateExpression(ISerializationContext context, CheckStateExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.CHECK_STATE_EXPRESSION__PROCESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.CHECK_STATE_EXPRESSION__PROCESS));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.CHECK_STATE_EXPRESSION__QUALFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.CHECK_STATE_EXPRESSION__QUALFIER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCheckStateExpressionAccess().getProcessProcessIDTerminalRuleCall_1_0_1(), semanticObject.eGet(ReflexPackage.Literals.CHECK_STATE_EXPRESSION__PROCESS, false));
		feeder.accept(grammarAccess.getCheckStateExpressionAccess().getQualfierStateQualifierEnumRuleCall_4_0(), semanticObject.getQualfier());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompareExpression returns CompareExpression
	 *     CompareExpression.CompareExpression_1_1_0 returns CompareExpression
	 *     EqualityExpression returns CompareExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns CompareExpression
	 *     BitAndExpression returns CompareExpression
	 *     BitAndExpression.BitAndExpression_1_0 returns CompareExpression
	 *     BitXorExpression returns CompareExpression
	 *     BitXorExpression.BitXorExpression_1_0 returns CompareExpression
	 *     BitOrExpression returns CompareExpression
	 *     BitOrExpression.BitOrExpression_1_0 returns CompareExpression
	 *     LogicalAndExpression returns CompareExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns CompareExpression
	 *     LogicalOrExpression returns CompareExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns CompareExpression
	 *
	 * Constraint:
	 *     (left=CompareExpression_CompareExpression_1_1_0 cmpOp=CompareOp right=CompareExpression)
	 */
	protected void sequence_CompareExpression(ISerializationContext context, CompareExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.COMPARE_EXPRESSION__CMP_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.COMPARE_EXPRESSION__CMP_OP));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareExpressionAccess().getCompareExpressionLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareExpressionAccess().getCmpOpCompareOpEnumRuleCall_1_1_1_0(), semanticObject.getCmpOp());
		feeder.accept(grammarAccess.getCompareExpressionAccess().getRightCompareExpressionParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CompoundStatement returns StatementBlock
	 *     Statement returns StatementBlock
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_CompoundStatement(ISerializationContext context, StatementBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Const returns Const
	 *     IdReference returns Const
	 *
	 * Constraint:
	 *     (type=ReflexType name=ID constValue=Expression)
	 */
	protected void sequence_Const(ISerializationContext context, Const semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.CONST__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.CONST__TYPE));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.CONST__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.CONST__NAME));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.CONST__CONST_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.CONST__CONST_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstAccess().getTypeReflexTypeParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getConstAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConstAccess().getConstValueExpressionParserRuleCall_4_0(), semanticObject.getConstValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ProcessVariable returns PhysicalVariable
	 *     DeclaredVariable returns PhysicalVariable
	 *     IdReference returns PhysicalVariable
	 *
	 * Constraint:
	 *     (type=IntegerType name=ID port=RegisterPortMapping shared='shared'?)
	 */
	protected void sequence_DeclaredVariable_PhysicalVariable(ISerializationContext context, PhysicalVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessVariable returns ProgramVariable
	 *     DeclaredVariable returns ProgramVariable
	 *     IdReference returns ProgramVariable
	 *
	 * Constraint:
	 *     (type=ReflexType name=ID shared='shared'?)
	 */
	protected void sequence_DeclaredVariable_ProgramVariable(ISerializationContext context, ProgramVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumMember returns EnumMember
	 *     IdReference returns EnumMember
	 *
	 * Constraint:
	 *     (name=ID value=Expression?)
	 */
	protected void sequence_EnumMember(ISerializationContext context, EnumMember semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Enum returns Enum
	 *
	 * Constraint:
	 *     (identifier=ID enumMembers+=EnumMember enumMembers+=EnumMember*)
	 */
	protected void sequence_Enum(ISerializationContext context, ru.iaie.reflex.reflex.Enum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EqualityExpression returns EqualityExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns EqualityExpression
	 *     BitAndExpression returns EqualityExpression
	 *     BitAndExpression.BitAndExpression_1_0 returns EqualityExpression
	 *     BitXorExpression returns EqualityExpression
	 *     BitXorExpression.BitXorExpression_1_0 returns EqualityExpression
	 *     BitOrExpression returns EqualityExpression
	 *     BitOrExpression.BitOrExpression_1_0 returns EqualityExpression
	 *     LogicalAndExpression returns EqualityExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns EqualityExpression
	 *     LogicalOrExpression returns EqualityExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns EqualityExpression
	 *
	 * Constraint:
	 *     (left=EqualityExpression_EqualityExpression_1_0 eqCmpOp=CompareEqOp right=EqualityExpression)
	 */
	protected void sequence_EqualityExpression(ISerializationContext context, EqualityExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.EQUALITY_EXPRESSION__EQ_CMP_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.EQUALITY_EXPRESSION__EQ_CMP_OP));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityExpressionAccess().getEqualityExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityExpressionAccess().getEqCmpOpCompareEqOpEnumRuleCall_1_1_0(), semanticObject.getEqCmpOp());
		feeder.accept(grammarAccess.getEqualityExpressionAccess().getRightEqualityExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ErrorStat
	 *     ErrorStat returns ErrorStat
	 *
	 * Constraint:
	 *     process=[Process|ID]?
	 */
	protected void sequence_ErrorStat(ISerializationContext context, ErrorStat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCall returns FunctionCall
	 *     UnaryExpression returns FunctionCall
	 *     CastExpression returns FunctionCall
	 *     MultiplicativeExpression returns FunctionCall
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns FunctionCall
	 *     AdditiveExpression returns FunctionCall
	 *     AdditiveExpression.AdditiveExpression_1_0 returns FunctionCall
	 *     ShiftExpression returns FunctionCall
	 *     ShiftExpression.ShiftExpression_1_0 returns FunctionCall
	 *     CompareExpression returns FunctionCall
	 *     CompareExpression.CompareExpression_1_1_0 returns FunctionCall
	 *     EqualityExpression returns FunctionCall
	 *     EqualityExpression.EqualityExpression_1_0 returns FunctionCall
	 *     BitAndExpression returns FunctionCall
	 *     BitAndExpression.BitAndExpression_1_0 returns FunctionCall
	 *     BitXorExpression returns FunctionCall
	 *     BitXorExpression.BitXorExpression_1_0 returns FunctionCall
	 *     BitOrExpression returns FunctionCall
	 *     BitOrExpression.BitOrExpression_1_0 returns FunctionCall
	 *     LogicalAndExpression returns FunctionCall
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns FunctionCall
	 *     LogicalOrExpression returns FunctionCall
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns FunctionCall
	 *
	 * Constraint:
	 *     (function=[Function|ID] (args+=Expression args+=Expression*)?)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (returnType=CType name=ID argTypes+=CType argTypes+=CType*)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfElseStat
	 *     IfElseStat returns IfElseStat
	 *
	 * Constraint:
	 *     (cond=Expression then=Statement else=Statement?)
	 */
	protected void sequence_IfElseStat(ISerializationContext context, IfElseStat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProcessVariable returns ImportedVariable
	 *     ImportedVariable returns ImportedVariable
	 *     IdReference returns ImportedVariable
	 *
	 * Constraint:
	 *     (variables+=[DeclaredVariable|ID] variables+=[DeclaredVariable|ID]* process=[Process|ID])
	 */
	protected void sequence_ImportedVariable(ISerializationContext context, ImportedVariable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InfixOp returns InfixOp
	 *     UnaryExpression returns InfixOp
	 *     CastExpression returns InfixOp
	 *     MultiplicativeExpression returns InfixOp
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns InfixOp
	 *     AdditiveExpression returns InfixOp
	 *     AdditiveExpression.AdditiveExpression_1_0 returns InfixOp
	 *     ShiftExpression returns InfixOp
	 *     ShiftExpression.ShiftExpression_1_0 returns InfixOp
	 *     CompareExpression returns InfixOp
	 *     CompareExpression.CompareExpression_1_1_0 returns InfixOp
	 *     EqualityExpression returns InfixOp
	 *     EqualityExpression.EqualityExpression_1_0 returns InfixOp
	 *     BitAndExpression returns InfixOp
	 *     BitAndExpression.BitAndExpression_1_0 returns InfixOp
	 *     BitXorExpression returns InfixOp
	 *     BitXorExpression.BitXorExpression_1_0 returns InfixOp
	 *     BitOrExpression returns InfixOp
	 *     BitOrExpression.BitOrExpression_1_0 returns InfixOp
	 *     LogicalAndExpression returns InfixOp
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns InfixOp
	 *     LogicalOrExpression returns InfixOp
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns InfixOp
	 *
	 * Constraint:
	 *     (op=InfixPostfixOp varId=ID)
	 */
	protected void sequence_InfixOp(ISerializationContext context, InfixOp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.INFIX_OP__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.INFIX_OP__OP));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.INFIX_OP__VAR_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.INFIX_OP__VAR_ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInfixOpAccess().getOpInfixPostfixOpEnumRuleCall_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getInfixOpAccess().getVarIdIDTerminalRuleCall_1_0(), semanticObject.getVarId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalAndExpression returns LogicalAndExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns LogicalAndExpression
	 *     LogicalOrExpression returns LogicalAndExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns LogicalAndExpression
	 *
	 * Constraint:
	 *     (left=LogicalAndExpression_LogicalAndExpression_1_0 right=LogicalAndExpression)
	 */
	protected void sequence_LogicalAndExpression(ISerializationContext context, LogicalAndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalAndExpressionAccess().getLogicalAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicalAndExpressionAccess().getRightLogicalAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalOrExpression returns LogicalOrExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns LogicalOrExpression
	 *
	 * Constraint:
	 *     (left=LogicalOrExpression_LogicalOrExpression_1_0 right=LogicalOrExpression)
	 */
	protected void sequence_LogicalOrExpression(ISerializationContext context, LogicalOrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalOrExpressionAccess().getLogicalOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicalOrExpressionAccess().getRightLogicalOrExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicativeExpression returns MultiplicativeExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns MultiplicativeExpression
	 *     AdditiveExpression returns MultiplicativeExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns MultiplicativeExpression
	 *     ShiftExpression returns MultiplicativeExpression
	 *     ShiftExpression.ShiftExpression_1_0 returns MultiplicativeExpression
	 *     CompareExpression returns MultiplicativeExpression
	 *     CompareExpression.CompareExpression_1_1_0 returns MultiplicativeExpression
	 *     EqualityExpression returns MultiplicativeExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns MultiplicativeExpression
	 *     BitAndExpression returns MultiplicativeExpression
	 *     BitAndExpression.BitAndExpression_1_0 returns MultiplicativeExpression
	 *     BitXorExpression returns MultiplicativeExpression
	 *     BitXorExpression.BitXorExpression_1_0 returns MultiplicativeExpression
	 *     BitOrExpression returns MultiplicativeExpression
	 *     BitOrExpression.BitOrExpression_1_0 returns MultiplicativeExpression
	 *     LogicalAndExpression returns MultiplicativeExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns MultiplicativeExpression
	 *     LogicalOrExpression returns MultiplicativeExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns MultiplicativeExpression
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpression_MultiplicativeExpression_1_0 mulOp=MultiplicativeOp right=CastExpression)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, MultiplicativeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.MULTIPLICATIVE_EXPRESSION__MUL_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.MULTIPLICATIVE_EXPRESSION__MUL_OP));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getMultiplicativeExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getMulOpMultiplicativeOpEnumRuleCall_1_1_0(), semanticObject.getMulOp());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getRightCastExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVariable returns PhysicalVariable
	 *     PhysicalVariable returns PhysicalVariable
	 *
	 * Constraint:
	 *     (type=IntegerType name=ID port=RegisterPortMapping)
	 */
	protected void sequence_PhysicalVariable(ISerializationContext context, PhysicalVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.PHYSICAL_VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.PHYSICAL_VARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.PHYSICAL_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.PHYSICAL_VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.PHYSICAL_VARIABLE__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.PHYSICAL_VARIABLE__PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPhysicalVariableAccess().getTypeIntegerTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getPhysicalVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPhysicalVariableAccess().getPortRegisterPortMappingParserRuleCall_3_0(), semanticObject.getPort());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PostfixOp returns PostfixOp
	 *     UnaryExpression returns PostfixOp
	 *     CastExpression returns PostfixOp
	 *     MultiplicativeExpression returns PostfixOp
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns PostfixOp
	 *     AdditiveExpression returns PostfixOp
	 *     AdditiveExpression.AdditiveExpression_1_0 returns PostfixOp
	 *     ShiftExpression returns PostfixOp
	 *     ShiftExpression.ShiftExpression_1_0 returns PostfixOp
	 *     CompareExpression returns PostfixOp
	 *     CompareExpression.CompareExpression_1_1_0 returns PostfixOp
	 *     EqualityExpression returns PostfixOp
	 *     EqualityExpression.EqualityExpression_1_0 returns PostfixOp
	 *     BitAndExpression returns PostfixOp
	 *     BitAndExpression.BitAndExpression_1_0 returns PostfixOp
	 *     BitXorExpression returns PostfixOp
	 *     BitXorExpression.BitXorExpression_1_0 returns PostfixOp
	 *     BitOrExpression returns PostfixOp
	 *     BitOrExpression.BitOrExpression_1_0 returns PostfixOp
	 *     LogicalAndExpression returns PostfixOp
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns PostfixOp
	 *     LogicalOrExpression returns PostfixOp
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns PostfixOp
	 *
	 * Constraint:
	 *     (varId=ID op=InfixPostfixOp)
	 */
	protected void sequence_PostfixOp(ISerializationContext context, PostfixOp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.POSTFIX_OP__VAR_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.POSTFIX_OP__VAR_ID));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.POSTFIX_OP__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.POSTFIX_OP__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostfixOpAccess().getVarIdIDTerminalRuleCall_0_0(), semanticObject.getVarId());
		feeder.accept(grammarAccess.getPostfixOpAccess().getOpInfixPostfixOpEnumRuleCall_1_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpression returns PrimaryExpression
	 *     UnaryExpression returns PrimaryExpression
	 *     CastExpression returns PrimaryExpression
	 *     MultiplicativeExpression returns PrimaryExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns PrimaryExpression
	 *     AdditiveExpression returns PrimaryExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns PrimaryExpression
	 *     ShiftExpression returns PrimaryExpression
	 *     ShiftExpression.ShiftExpression_1_0 returns PrimaryExpression
	 *     CompareExpression returns PrimaryExpression
	 *     CompareExpression.CompareExpression_1_1_0 returns PrimaryExpression
	 *     EqualityExpression returns PrimaryExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns PrimaryExpression
	 *     BitAndExpression returns PrimaryExpression
	 *     BitAndExpression.BitAndExpression_1_0 returns PrimaryExpression
	 *     BitXorExpression returns PrimaryExpression
	 *     BitXorExpression.BitXorExpression_1_0 returns PrimaryExpression
	 *     BitOrExpression returns PrimaryExpression
	 *     BitOrExpression.BitOrExpression_1_0 returns PrimaryExpression
	 *     LogicalAndExpression returns PrimaryExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns PrimaryExpression
	 *     LogicalOrExpression returns PrimaryExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns PrimaryExpression
	 *
	 * Constraint:
	 *     (reference=[IdReference|ID] | integer=INTEGER | floating=FLOAT | boolean=BoolLiteral | nestedExpr=Expression)
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Process returns Process
	 *
	 * Constraint:
	 *     (annotations+=Annotation* name=ID variables+=ProcessVariable* states+=State*)
	 */
	protected void sequence_Process(ISerializationContext context, ru.iaie.reflex.reflex.Process semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GlobalVariable returns ProgramVariable
	 *     ProgramVariable returns ProgramVariable
	 *
	 * Constraint:
	 *     (type=ReflexType name=ID)
	 */
	protected void sequence_ProgramVariable(ISerializationContext context, ProgramVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.PROGRAM_VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.PROGRAM_VARIABLE__TYPE));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.PROGRAM_VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.PROGRAM_VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getProgramVariableAccess().getTypeReflexTypeParserRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getProgramVariableAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (
	 *         annotations+=Annotation* 
	 *         name=ID 
	 *         ticks=Tact? 
	 *         (
	 *             consts+=Const | 
	 *             enums+=Enum | 
	 *             functions+=Function | 
	 *             globalVars+=GlobalVariable | 
	 *             registers+=Register | 
	 *             processes+=Process
	 *         )*
	 *     )
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReflexType returns ReflexType
	 *
	 * Constraint:
	 *     {ReflexType}
	 */
	protected void sequence_ReflexType(ISerializationContext context, ReflexType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RegisterPortMapping returns RegisterPortMapping
	 *
	 * Constraint:
	 *     (register=[Register|ID] portBit=INTEGER?)
	 */
	protected void sequence_RegisterPortMapping(ISerializationContext context, RegisterPortMapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Register returns Register
	 *
	 * Constraint:
	 *     (type=RegisterType name=ID addr1=INTEGER addr2=INTEGER regSize=INTEGER)
	 */
	protected void sequence_Register(ISerializationContext context, Register semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.REGISTER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.REGISTER__TYPE));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.REGISTER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.REGISTER__NAME));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.REGISTER__ADDR1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.REGISTER__ADDR1));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.REGISTER__ADDR2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.REGISTER__ADDR2));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.REGISTER__REG_SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.REGISTER__REG_SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRegisterAccess().getTypeRegisterTypeEnumRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getRegisterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRegisterAccess().getAddr1INTEGERTerminalRuleCall_2_0(), semanticObject.getAddr1());
		feeder.accept(grammarAccess.getRegisterAccess().getAddr2INTEGERTerminalRuleCall_3_0(), semanticObject.getAddr2());
		feeder.accept(grammarAccess.getRegisterAccess().getRegSizeINTEGERTerminalRuleCall_4_0(), semanticObject.getRegSize());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ResetStat
	 *     ResetStat returns ResetStat
	 *
	 * Constraint:
	 *     {ResetStat}
	 */
	protected void sequence_ResetStat(ISerializationContext context, ResetStat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns RestartStat
	 *     RestartStat returns RestartStat
	 *
	 * Constraint:
	 *     {RestartStat}
	 */
	protected void sequence_RestartStat(ISerializationContext context, RestartStat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SetStateStat
	 *     SetStateStat returns SetStateStat
	 *
	 * Constraint:
	 *     (state=[State|ID] | next?='next')
	 */
	protected void sequence_SetStateStat(ISerializationContext context, SetStateStat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ShiftExpression returns ShiftExpression
	 *     ShiftExpression.ShiftExpression_1_0 returns ShiftExpression
	 *     CompareExpression returns ShiftExpression
	 *     CompareExpression.CompareExpression_1_1_0 returns ShiftExpression
	 *     EqualityExpression returns ShiftExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns ShiftExpression
	 *     BitAndExpression returns ShiftExpression
	 *     BitAndExpression.BitAndExpression_1_0 returns ShiftExpression
	 *     BitXorExpression returns ShiftExpression
	 *     BitXorExpression.BitXorExpression_1_0 returns ShiftExpression
	 *     BitOrExpression returns ShiftExpression
	 *     BitOrExpression.BitOrExpression_1_0 returns ShiftExpression
	 *     LogicalAndExpression returns ShiftExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns ShiftExpression
	 *     LogicalOrExpression returns ShiftExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns ShiftExpression
	 *
	 * Constraint:
	 *     (left=ShiftExpression_ShiftExpression_1_0 shiftOp=ShiftOp right=ShiftExpression)
	 */
	protected void sequence_ShiftExpression(ISerializationContext context, ShiftExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.SHIFT_EXPRESSION__SHIFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.SHIFT_EXPRESSION__SHIFT_OP));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShiftExpressionAccess().getShiftExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getShiftExpressionAccess().getShiftOpShiftOpEnumRuleCall_1_1_0(), semanticObject.getShiftOp());
		feeder.accept(grammarAccess.getShiftExpressionAccess().getRightShiftExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StartProcStat
	 *     StartProcStat returns StartProcStat
	 *
	 * Constraint:
	 *     process=[Process|ID]
	 */
	protected void sequence_StartProcStat(ISerializationContext context, StartProcStat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.START_PROC_STAT__PROCESS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.START_PROC_STAT__PROCESS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStartProcStatAccess().getProcessProcessIDTerminalRuleCall_2_0_1(), semanticObject.eGet(ReflexPackage.Literals.START_PROC_STAT__PROCESS, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     State returns State
	 *
	 * Constraint:
	 *     (annotations+=Annotation* name=ID looped?='looped'? stateFunction=StatementSequence timeoutFunction=TimeoutFunction?)
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StatementSequence returns StatementSequence
	 *
	 * Constraint:
	 *     statements+=Statement*
	 */
	protected void sequence_StatementSequence(ISerializationContext context, StatementSequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Statement
	 *
	 * Constraint:
	 *     {Statement}
	 */
	protected void sequence_Statement(ISerializationContext context, Statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StopProcStat
	 *     StopProcStat returns StopProcStat
	 *
	 * Constraint:
	 *     process=[Process|ID]?
	 */
	protected void sequence_StopProcStat(ISerializationContext context, StopProcStat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SwitchStat
	 *     SwitchStat returns SwitchStat
	 *
	 * Constraint:
	 *     (expr=Expression options+=CaseStat*)
	 */
	protected void sequence_SwitchStat(ISerializationContext context, SwitchStat semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tact returns Tact
	 *
	 * Constraint:
	 *     value=INTEGER
	 */
	protected void sequence_Tact(ISerializationContext context, Tact semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.TACT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.TACT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTactAccess().getValueINTEGERTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TimeoutFunction returns TimeoutFunction
	 *
	 * Constraint:
	 *     ((time=Time | ref=[IdReference|ID]) body=Statement)
	 */
	protected void sequence_TimeAmountOrRef_TimeoutFunction(ISerializationContext context, TimeoutFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Time returns Time
	 *
	 * Constraint:
	 *     ticks=INTEGER
	 */
	protected void sequence_Time(ISerializationContext context, Time semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.TIME__TICKS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.TIME__TICKS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeAccess().getTicksINTEGERTerminalRuleCall_0(), semanticObject.getTicks());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnaryExpression returns UnaryExpression
	 *     CastExpression returns UnaryExpression
	 *     MultiplicativeExpression returns UnaryExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0 returns UnaryExpression
	 *     AdditiveExpression returns UnaryExpression
	 *     AdditiveExpression.AdditiveExpression_1_0 returns UnaryExpression
	 *     ShiftExpression returns UnaryExpression
	 *     ShiftExpression.ShiftExpression_1_0 returns UnaryExpression
	 *     CompareExpression returns UnaryExpression
	 *     CompareExpression.CompareExpression_1_1_0 returns UnaryExpression
	 *     EqualityExpression returns UnaryExpression
	 *     EqualityExpression.EqualityExpression_1_0 returns UnaryExpression
	 *     BitAndExpression returns UnaryExpression
	 *     BitAndExpression.BitAndExpression_1_0 returns UnaryExpression
	 *     BitXorExpression returns UnaryExpression
	 *     BitXorExpression.BitXorExpression_1_0 returns UnaryExpression
	 *     BitOrExpression returns UnaryExpression
	 *     BitOrExpression.BitOrExpression_1_0 returns UnaryExpression
	 *     LogicalAndExpression returns UnaryExpression
	 *     LogicalAndExpression.LogicalAndExpression_1_0 returns UnaryExpression
	 *     LogicalOrExpression returns UnaryExpression
	 *     LogicalOrExpression.LogicalOrExpression_1_0 returns UnaryExpression
	 *
	 * Constraint:
	 *     (unaryOp=UnaryOp right=CastExpression)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.UNARY_EXPRESSION__UNARY_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.UNARY_EXPRESSION__UNARY_OP));
			if (transientValues.isValueTransient(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ReflexPackage.Literals.LOGICAL_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getUnaryOpUnaryOpEnumRuleCall_4_0_0(), semanticObject.getUnaryOp());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getRightCastExpressionParserRuleCall_4_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
}
